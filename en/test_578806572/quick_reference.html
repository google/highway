<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API synopsis / quick reference &mdash; HIGHWAY nightly documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/toggle.css" />

  
    <link rel="shortcut icon" href="_static/logo-32x32.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Design philosophy" href="design_philosophy.html" />
    <link rel="prev" title="Efficient and performance-portable vector software" href="README.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            HIGHWAY
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                test_578806572
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Efficient and performance-portable vector software</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API synopsis / quick reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#high-level-overview">High-level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#static-vs-dynamic-dispatch">Static vs. dynamic dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#headers">Headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#notation-in-this-doc">Notation in this doc</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector-and-tag-types">Vector and tag types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-unspecified-vector-types">Using unspecified vector types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#targets">Targets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operations">Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-setting-lanes">Getting/setting lanes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-setting-blocks">Getting/setting blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printing">Printing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuples">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic">Arithmetic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#min-max">Min/Max</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiply">Multiply</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fused-multiply-add">Fused multiply-add</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masked-arithmetic">Masked arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zero-masked-arithmetic">Zero masked arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complex-number-operations">Complex number operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shifts">Shifts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masked-shifts">Masked Shifts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#floating-point-rounding">Floating-point rounding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#floating-point-classification">Floating-point classification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masked-floating-point-classification">Masked floating-point classification</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#logical">Logical</a></li>
<li class="toctree-l3"><a class="reference internal" href="#masks">Masks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#create-mask">Create mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert-mask">Convert mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="#combine-mask">Combine mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slide-mask-across-blocks">Slide mask across blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-mask">Test mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ternary-operator-for-masks">Ternary operator for masks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logical-mask">Logical mask</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compress">Compress</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expand">Expand</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comparisons">Comparisons</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#masked-comparison">Masked comparison</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#memory">Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#load">Load</a></li>
<li class="toctree-l4"><a class="reference internal" href="#store">Store</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interleaved">Interleaved</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scatter-gather">Scatter/Gather</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cache-control">Cache control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-conversion">Type conversion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#single-vector-demotion">Single vector demotion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#single-vector-promotion">Single vector promotion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#two-vector-demotion">Two-vector demotion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#combine">Combine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blockwise">Blockwise</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interleave">Interleave</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zip">Zip</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shift-within-blocks">Shift within blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-fixed-pattern-permutations-within-blocks">Other fixed-pattern permutations within blocks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swizzle">Swizzle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reverse">Reverse</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-specified-permutation-across-blocks">User-specified permutation across blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slide-across-blocks">Slide across blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-fixed-pattern-across-blocks">Other fixed-pattern across blocks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reductions">Reductions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#masked-reductions">Masked reductions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#crypto">Crypto</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#preprocessor-macros">Preprocessor macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-macros">Advanced macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#detecting-supported-targets">Detecting supported targets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-configuration-macros">Advanced configuration macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compiler-support">Compiler support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-traits">Type traits</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocation">Memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#speeding-up-code-for-older-x86-platforms">Speeding up code for older x86 platforms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="design_philosophy.html">Design philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="impl_details.html">Highway implementation details</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_testing_process.html">Release testing process</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">HIGHWAY</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API synopsis / quick reference</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/google/highway/blob/master/docs/quick_reference.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="api-synopsis-quick-reference">
<h1>API synopsis / quick reference<a class="headerlink" href="#api-synopsis-quick-reference" title="Permalink to this heading"></a></h1>
<div class="section" id="high-level-overview">
<h2>High-level overview<a class="headerlink" href="#high-level-overview" title="Permalink to this heading"></a></h2>
<p>Highway is a collection of ‘ops’: platform-agnostic pure functions that
operate on tuples (multiple values of the same type). These functions
are implemented using platform-specific intrinsics, which map to
SIMD/vector instructions.</p>
<p>Your code calls these ops and uses them to implement the desired
algorithm. Alternatively, <code class="docutils literal notranslate"><span class="pre">hwy/contrib</span></code> also includes higher-level
algorithms such as <code class="docutils literal notranslate"><span class="pre">FindIf</span></code> or <code class="docutils literal notranslate"><span class="pre">VQSort</span></code> implemented using these ops.</p>
</div>
<div class="section" id="static-vs-dynamic-dispatch">
<h2>Static vs. dynamic dispatch<a class="headerlink" href="#static-vs-dynamic-dispatch" title="Permalink to this heading"></a></h2>
<p>Highway supports two ways of deciding which instruction sets to use:
static or dynamic dispatch.</p>
<p>Static means targeting a single instruction set, typically the best one
enabled by the given compiler flags. This has no runtime overhead and
only compiles your code once, but because compiler flags are typically
conservative, you will not benefit from more recent instruction sets.
Conversely, if you run the binary on a CPU that does not support this
instruction set, it will crash.</p>
<p>Dynamic dispatch means compiling your code multiple times and choosing
the best available implementation at runtime. Highway supports three
ways of doing this:</p>
<ul>
<li><p>Highway can take care of everything including compilation (by
re-<code class="docutils literal notranslate"><span class="pre">#include</span></code> your code), setting the required compiler #pragmas,
and dispatching to the best available implementation. The only
changes to your code relative to static dispatch are adding
<code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">HWY_TARGET_INCLUDE</span></code>,
<code class="docutils literal notranslate"><span class="pre">#include</span>&#160;&#160;&#160;&#160; <span class="pre">&quot;third_party/highway/hwy/foreach_target.h&quot;</span></code> (which
must come before any inclusion of highway.h) and calling
<code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code> instead of <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_DISPATCH</span></code>.</p></li>
<li><p>Some build systems (e.g. Apple) support the concept of ‘fat’ binaries
which contain code for multiple architectures or instruction sets.
Then, the operating system or loader typically takes care of calling
the appropriate code. Highway interoperates with this by using the
instruction set requested by the current compiler flags during each
compilation pass. Your code is the same as with static dispatch.</p>
<p>Note that this method replicates the entire binary, whereas the
Highway-assisted dynamic dispatch method only replicates your SIMD
code, which is typically a small fraction of the total size.</p>
</li>
<li><p>Because Highway is a library (as opposed to a code generator or
compiler), the dynamic dispatch method can be inspected, and made to
interoperate with existing systems. For compilation, you can replace
foreach_target.h if your build system supports compiling for multiple
targets. For choosing the best available target, you can replace
Highway’s CPU detection and decision with your own.
<code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code> calls into a table of function pointers with
a zero-based index indicating the desired target. Instead of calling
it immediately, you can also save the function pointer returned by
<code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_POINTER</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_POINTER</span></code> returns
the same pointer that <code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code> would. When either of
them are first invoked, the function pointer first detects the CPU,
then calls your actual function. You can call
<code class="docutils literal notranslate"><span class="pre">GetChosenTarget().Update(SupportedTargets());</span></code> to ensure future
dynamic dispatch avoids the overhead of CPU detection. You can also
replace the table lookup with your own choice of index, or even call
e.g. <code class="docutils literal notranslate"><span class="pre">N_AVX2::YourFunction</span></code> directly.</p></li>
</ul>
<p>Examples of both static and dynamic dispatch are provided in examples/.
Typically, the function that does the dispatch receives a pointer to one
or more arrays. Due to differing ABIs, we recommend only passing vector
arguments to functions that are inlined, and in particular not the
top-level function that does the dispatch.</p>
<p>Note that if your compiler is pre-configured to generate code only for a
specific architecture, or your build flags include -m flags that specify
a baseline CPU architecture, then this can interfere with dynamic
dispatch, which aims to build code for all attainable targets. One
example is specializing for a Raspberry Pi CPU that lacks AES, by
specifying <code class="docutils literal notranslate"><span class="pre">-march=armv8-a+crc</span></code>. When we build the <code class="docutils literal notranslate"><span class="pre">HWY_NEON</span></code> target
(which would only be used if the CPU actually does have AES), there is a
conflict between the <code class="docutils literal notranslate"><span class="pre">arch=armv8-a+crypto</span></code> that is set via pragma only
for the vector code, and the global <code class="docutils literal notranslate"><span class="pre">-march</span></code>. This results in a
compile error, see #1460, #1570, and #1707. As a workaround, we
recommend avoiding -m flags if possible, and otherwise defining
<code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_STATIC</span></code> or <code class="docutils literal notranslate"><span class="pre">HWY_SKIP_NON_BEST_BASELINE</span></code> when
building Highway as well as any user code that includes Highway headers.
As a result, only the baseline target, or targets at least as good as
the baseline, will be compiled. Note that it is fine for user code to
still call <code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code>. When Highway is only built for a
single target, <code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code> results in the same direct call
that <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_DISPATCH</span></code> would produce.</p>
</div>
<div class="section" id="headers">
<h2>Headers<a class="headerlink" href="#headers" title="Permalink to this heading"></a></h2>
<p>The public headers are:</p>
<ul class="simple">
<li><p>hwy/highway.h: main header, included from source AND/OR header files
that use vector types. Note that including in headers may increase
compile time, but allows declaring functions implemented out of line.</p></li>
<li><p>hwy/base.h: included from headers that only need
compiler/platform-dependent definitions (e.g. <code class="docutils literal notranslate"><span class="pre">PopCount</span></code>) without
the full highway.h.</p></li>
<li><p>hwy/foreach_target.h: re-includes the translation unit (specified by
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET_INCLUDE</span></code>) once per enabled target to generate code from
the same source code. highway.h must still be included.</p></li>
<li><p>hwy/aligned_allocator.h: defines functions for allocating memory with
alignment suitable for <code class="docutils literal notranslate"><span class="pre">Load</span></code>/<code class="docutils literal notranslate"><span class="pre">Store</span></code>.</p></li>
<li><p>hwy/cache_control.h: defines standalone functions to control caching
(e.g. prefetching), independent of actual SIMD.</p></li>
<li><p>hwy/nanobenchmark.h: library for precisely measuring elapsed time
(under varying inputs) for benchmarking small/medium regions of code.</p></li>
<li><p>hwy/print-inl.h: defines Print() for writing vector lanes to stderr.</p></li>
<li><p>hwy/tests/test_util-inl.h: defines macros for invoking tests on all
available targets, plus per-target functions useful in tests.</p></li>
</ul>
<p>Highway provides helper macros to simplify your vector code and ensure
support for dynamic dispatch. To use these, add the following to the
start and end of any vector code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;hwy/highway.h&quot;</span>
<span class="n">HWY_BEFORE_NAMESPACE</span><span class="p">();</span>  <span class="o">//</span> <span class="n">at</span> <span class="n">file</span> <span class="n">scope</span>
<span class="n">namespace</span> <span class="n">project</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">optional</span>
<span class="n">namespace</span> <span class="n">HWY_NAMESPACE</span> <span class="p">{</span>

<span class="o">//</span> <span class="n">implementation</span>

<span class="o">//</span> <span class="n">NOLINTNEXTLINE</span><span class="p">(</span><span class="n">google</span><span class="o">-</span><span class="n">readability</span><span class="o">-</span><span class="n">namespace</span><span class="o">-</span><span class="n">comments</span><span class="p">)</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">namespace</span> <span class="n">HWY_NAMESPACE</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">namespace</span> <span class="n">project</span> <span class="o">-</span> <span class="n">optional</span>
<span class="n">HWY_AFTER_NAMESPACE</span><span class="p">();</span>
</pre></div>
</div>
<p>If you choose not to use the <code class="docutils literal notranslate"><span class="pre">BEFORE/AFTER</span></code> lines, you must prefix any
function that calls Highway ops such as <code class="docutils literal notranslate"><span class="pre">Load</span></code> with <code class="docutils literal notranslate"><span class="pre">HWY_ATTR</span></code>.
Either of these will set the compiler #pragma required to generate
vector code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">HWY_NAMESPACE</span></code> lines ensure each instantiation of your code (one
per target) resides in a unique namespace, thus preventing ODR
violations. You can omit this if your code will only ever use static
dispatch.</p>
</div>
<div class="section" id="notation-in-this-doc">
<h2>Notation in this doc<a class="headerlink" href="#notation-in-this-doc" title="Permalink to this heading"></a></h2>
<p>By vector ‘lanes’, we mean the ‘elements’ of that vector. Analogous to
the lanes of a highway or swimming pool, most operations act on each
lane independently, but it is possible for lanes to interact and change
order via ‘swizzling’ ops.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> denotes the type of a vector lane (integer or floating-point);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> is a size_t value that governs (but is not necessarily
identical to) the number of lanes;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">D</span></code> is shorthand for a zero-sized tag type <code class="docutils literal notranslate"><span class="pre">Simd&lt;T,</span> <span class="pre">N,</span> <span class="pre">kPow2&gt;</span></code>,
used to select the desired overloaded function (see next section).
Use aliases such as <code class="docutils literal notranslate"><span class="pre">ScalableTag</span></code> instead of referring to this type
directly;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> is an lvalue of type <code class="docutils literal notranslate"><span class="pre">D</span></code>, passed as a function argument
e.g. to Zero;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code> is the type of a vector, which may be a class or built-in type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is analogous to C++ array notation, with zero-based index
<code class="docutils literal notranslate"><span class="pre">i</span></code> from the starting address of the vector <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></li>
</ul>
</div>
<div class="section" id="vector-and-tag-types">
<h2>Vector and tag types<a class="headerlink" href="#vector-and-tag-types" title="Permalink to this heading"></a></h2>
<p>Highway vectors consist of one or more ‘lanes’ of the same built-in type
<code class="docutils literal notranslate"><span class="pre">T</span></code>: <code class="docutils literal notranslate"><span class="pre">uint##_t,</span> <span class="pre">int##_t</span></code> for <code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">=</span> <span class="pre">8,</span> <span class="pre">16,</span> <span class="pre">32,</span> <span class="pre">64</span></code>, or
<code class="docutils literal notranslate"><span class="pre">float##_t</span></code> for <code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">=</span> <span class="pre">16,</span> <span class="pre">32,</span> <span class="pre">64</span></code> and <code class="docutils literal notranslate"><span class="pre">bfloat16_t</span></code>. <code class="docutils literal notranslate"><span class="pre">T</span></code> may be
retrieved via <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">IsIntegerLaneType&lt;T&gt;</span></code> evaluates to true
for these <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code> types.</p>
<p>Beware that <code class="docutils literal notranslate"><span class="pre">char</span></code> may differ from these types, and is not supported
directly. If your code loads from/stores to <code class="docutils literal notranslate"><span class="pre">char*</span></code>, use <code class="docutils literal notranslate"><span class="pre">T=uint8_t</span></code>
for Highway’s <code class="docutils literal notranslate"><span class="pre">d</span></code> tags (see below) or <code class="docutils literal notranslate"><span class="pre">T=int8_t</span></code> (which may enable
faster less-than/greater-than comparisons), and cast your <code class="docutils literal notranslate"><span class="pre">char*</span></code>
pointers to your <code class="docutils literal notranslate"><span class="pre">T*</span></code>.</p>
<p>In Highway, <code class="docutils literal notranslate"><span class="pre">float16_t</span></code> (an IEEE binary16 half-float) and
<code class="docutils literal notranslate"><span class="pre">bfloat16_t</span></code> (the upper 16 bits of an IEEE binary32 float) only
support load, store, and conversion to/from <code class="docutils literal notranslate"><span class="pre">float32_t</span></code>. The behavior
of infinity and NaN in <code class="docutils literal notranslate"><span class="pre">float16_t</span></code> is implementation-defined due to
Armv7. To ensure binary compatibility, these types are always wrapper
structs and cannot be initialized with values directly. You can convert
these values from/to float using <code class="docutils literal notranslate"><span class="pre">ConvertScalarTo</span></code>, or from/to their
underlying bit representation using <code class="docutils literal notranslate"><span class="pre">BitCastScalar</span></code>.</p>
<p>On RVV/SVE, vectors are sizeless and cannot be wrapped inside a class.
The Highway API allows using built-in types as vectors because
operations are expressed as overloaded functions. Instead of
constructors, overloaded initialization functions such as <code class="docutils literal notranslate"><span class="pre">Set</span></code> take a
zero-sized tag argument called <code class="docutils literal notranslate"><span class="pre">d</span></code> of type <code class="docutils literal notranslate"><span class="pre">D</span></code> and return an actual
vector of unspecified type.</p>
<p>The actual lane count (used to increment loop counters etc.) can be
obtained via <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>. To improve code generation
(constant-propagation) for targets with fixed-size vectors, this
function is <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">HWY_HAVE_CONSTEXPR_LANES</span></code>. Otherwise,
users must not assign <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> to <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> variables. You can
ensure this by using <code class="docutils literal notranslate"><span class="pre">HWY_LANES_CONSTEXPR</span></code> instead of <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.
To help detect mismatches, we define <code class="docutils literal notranslate"><span class="pre">HWY_HAVE_CONSTEXPR_LANES</span></code> to 0
in debug builds.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> might not be constexpr, it must also not be used as
array dimensions. Instead, storage for vectors should be dynamically
allocated, e.g. via <code class="docutils literal notranslate"><span class="pre">AllocateAligned(Lanes(d))</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> could potentially change at runtime. This is
currently unlikely, and will not be initiated by Highway without user
action, but could still happen in other circumstances:</p>
<ul class="simple">
<li><p>upon user request in future via special CPU instructions (switching
to ‘streaming SVE’ mode for Arm SME), or</p></li>
<li><p>via system software (<code class="docutils literal notranslate"><span class="pre">prctl(PR_SVE_SET_VL</span></code> on Linux for Arm SVE).
When the vector length is changed using this mechanism, all but the
lower 128 bits of vector registers are invalidated.</p></li>
</ul>
<p>Thus we discourage caching the result; it is typically used inside a
function or basic block. If the application anticipates that one of the
above circumstances could happen, it should ensure by some out-of-band
mechanism that such changes will not happen during the critical section
(the vector code which uses the result of the previously obtained
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">MaxLanes(d)</span></code> returns a (potentially loose) upper bound on
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>, and is always implemented as a constexpr function.</p>
<p>The actual lane count is guaranteed to be a power of two, even on SVE.
This simplifies alignment: remainders can be computed as
<code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">&amp;</span> <span class="pre">(Lanes(d)</span> <span class="pre">-</span> <span class="pre">1)</span></code> instead of an expensive modulo. It also
ensures loop trip counts that are a large power of two (at least
<code class="docutils literal notranslate"><span class="pre">MaxLanes</span></code>) are evenly divisible by the lane count, thus avoiding the
need for a second loop to handle remainders.</p>
<p><code class="docutils literal notranslate"><span class="pre">d</span></code> lvalues (a tag, NOT actual vector) are obtained using aliases:</p>
<ul>
<li><p>Most common: <code class="docutils literal notranslate"><span class="pre">ScalableTag&lt;T[,</span> <span class="pre">kPow2=0]&gt;</span> <span class="pre">d;</span></code> or the macro form
<code class="docutils literal notranslate"><span class="pre">HWY_FULL(T[,</span>&#160;&#160;&#160;&#160; <span class="pre">LMUL=1])</span> <span class="pre">d;</span></code>. With the default value of the
second argument, these both select full vectors which utilize all
available lanes.</p>
<p>Only for targets (e.g. RVV) that support register groups, the kPow2
(-3..3) and LMUL argument (1, 2, 4, 8) specify <code class="docutils literal notranslate"><span class="pre">LMUL</span></code>, the number
of registers in the group. This effectively multiplies the lane count
in each operation by <code class="docutils literal notranslate"><span class="pre">LMUL</span></code>, or left-shifts by <code class="docutils literal notranslate"><span class="pre">kPow2</span></code> (negative
values are understood as right-shifting by the absolute value). These
arguments will eventually be optional hints that may improve
performance on 1-2 wide machines (at the cost of reducing the
effective number of registers), but RVV target does not yet support
fractional <code class="docutils literal notranslate"><span class="pre">LMUL</span></code>. Thus, mixed-precision code (e.g. demoting float
to uint8_t) currently requires <code class="docutils literal notranslate"><span class="pre">LMUL</span></code> to be at least the ratio of
the sizes of the largest and smallest type, and smaller <code class="docutils literal notranslate"><span class="pre">d</span></code> to be
obtained via <code class="docutils literal notranslate"><span class="pre">Half&lt;DLarger&gt;</span></code>.</p>
<p>For other targets, <code class="docutils literal notranslate"><span class="pre">kPow2</span></code> must lie within [HWY_MIN_POW2,
HWY_MAX_POW2]. The <code class="docutils literal notranslate"><span class="pre">*Tag</span></code> aliases clamp to the upper bound but your
code should ensure the lower bound is not exceeded, typically by
specializing compile-time recursions for <code class="docutils literal notranslate"><span class="pre">kPow2</span></code> = <code class="docutils literal notranslate"><span class="pre">HWY_MIN_POW2</span></code>
(this avoids compile errors when <code class="docutils literal notranslate"><span class="pre">kPow2</span></code> is low enough that it is
no longer a valid shift count).</p>
</li>
<li><p>Less common: <code class="docutils literal notranslate"><span class="pre">CappedTag&lt;T,</span> <span class="pre">kCap&gt;</span> <span class="pre">d</span></code> or the macro form
<code class="docutils literal notranslate"><span class="pre">HWY_CAPPED(T,</span> <span class="pre">kCap)</span>&#160;&#160;&#160;&#160; <span class="pre">d;</span></code>. These select vectors or masks where
<em>no more than</em> the largest power of two not exceeding <code class="docutils literal notranslate"><span class="pre">kCap</span></code> lanes
have observable effects such as loading/storing to memory, or being
counted by <code class="docutils literal notranslate"><span class="pre">CountTrue</span></code>. The number of lanes may also be less; for
the <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code> target, vectors always have a single lane. For
example, <code class="docutils literal notranslate"><span class="pre">CappedTag&lt;T,</span> <span class="pre">3&gt;</span></code> will use up to two lanes.</p></li>
<li><p>For applications that require fixed-size vectors:
<code class="docutils literal notranslate"><span class="pre">FixedTag&lt;T,</span> <span class="pre">kCount&gt;</span> <span class="pre">d;</span></code> will select vectors where exactly
<code class="docutils literal notranslate"><span class="pre">kCount</span></code> lanes have observable effects. These may be implemented
using full vectors plus additional runtime cost for masking in
<code class="docutils literal notranslate"><span class="pre">Load</span></code> etc. <code class="docutils literal notranslate"><span class="pre">kCount</span></code> must be a power of two not exceeding
<code class="docutils literal notranslate"><span class="pre">HWY_LANES(T)</span></code>, which is one for <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code>. This tag can be
used when the <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code> target is anyway disabled (superseded by
a higher baseline) or unusable (due to use of ops such as
<code class="docutils literal notranslate"><span class="pre">TableLookupBytes</span></code>). As a convenience, we also provide
<code class="docutils literal notranslate"><span class="pre">Full128&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">Full64&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">Full32&lt;T&gt;</span></code> aliases which are
equivalent to <code class="docutils literal notranslate"><span class="pre">FixedTag&lt;T,</span> <span class="pre">16</span> <span class="pre">/</span> <span class="pre">sizeof(T)&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">FixedTag&lt;T,</span> <span class="pre">8</span> <span class="pre">/</span> <span class="pre">sizeof(T)&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">FixedTag&lt;T,</span> <span class="pre">4</span> <span class="pre">/</span> <span class="pre">sizeof(T)&gt;</span></code>.</p></li>
<li><p>The result of <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>/<code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> has half the lanes. To
obtain a corresponding <code class="docutils literal notranslate"><span class="pre">d</span></code>, use <code class="docutils literal notranslate"><span class="pre">Half&lt;decltype(d)&gt;</span></code>; the opposite
is <code class="docutils literal notranslate"><span class="pre">Twice&lt;&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BlockDFromD&lt;D&gt;</span></code> returns a <code class="docutils literal notranslate"><span class="pre">d</span></code> with a lane type of <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>
and <code class="docutils literal notranslate"><span class="pre">HWY_MIN(HWY_MAX_LANES_D(D),</span> <span class="pre">16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromD&lt;D&gt;))</span></code> lanes.</p></li>
</ul>
<p>User-specified lane counts or tuples of vectors could cause spills on
targets with fewer or smaller vectors. By contrast, Highway encourages
vector-length agnostic code, which is more performance-portable.</p>
<p>For mixed-precision code (e.g. <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> lanes promoted to <code class="docutils literal notranslate"><span class="pre">float</span></code>),
tags for the smaller types must be obtained from those of the larger
type (e.g. via <code class="docutils literal notranslate"><span class="pre">Rebind&lt;uint8_t,</span> <span class="pre">ScalableTag&lt;float&gt;&gt;</span></code>).</p>
</div>
<div class="section" id="using-unspecified-vector-types">
<h2>Using unspecified vector types<a class="headerlink" href="#using-unspecified-vector-types" title="Permalink to this heading"></a></h2>
<p>Vector types are unspecified and depend on the target. Your code could
define vector variables using <code class="docutils literal notranslate"><span class="pre">auto</span></code>, but it is more readable (due to
making the type visible) to use an alias such as <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code>, or
<code class="docutils literal notranslate"><span class="pre">decltype(Zero(d))</span></code>. Similarly, the mask type can be obtained via
<code class="docutils literal notranslate"><span class="pre">Mask&lt;D&gt;</span></code>. Often your code will first define a <code class="docutils literal notranslate"><span class="pre">d</span></code> lvalue using
<code class="docutils literal notranslate"><span class="pre">ScalableTag&lt;T&gt;</span></code>. You may wish to define an alias for your vector
types such as <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">VecT</span> <span class="pre">=</span> <span class="pre">Vec&lt;decltype(d)&gt;</span></code>. Do not use undocumented
types such as <code class="docutils literal notranslate"><span class="pre">Vec128</span></code>; these may work on most targets, but not all
(e.g. SVE).</p>
<p>Vectors are sizeless types on RVV/SVE. Therefore, vectors must not be
used in arrays/STL containers (use the lane type <code class="docutils literal notranslate"><span class="pre">T</span></code> instead), class
members, static/thread_local variables, new-expressions (use
<code class="docutils literal notranslate"><span class="pre">AllocateAligned</span></code> instead), and sizeof/pointer arithmetic (increment
<code class="docutils literal notranslate"><span class="pre">T*</span></code> by <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> instead).</p>
<p>Initializing constants requires a tag type <code class="docutils literal notranslate"><span class="pre">D</span></code>, or an lvalue <code class="docutils literal notranslate"><span class="pre">d</span></code> of
that type. The <code class="docutils literal notranslate"><span class="pre">D</span></code> can be passed as a template argument or obtained
from a vector type <code class="docutils literal notranslate"><span class="pre">V</span></code> via <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">TFromV&lt;V&gt;</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DFromV&lt;V&gt;&gt;</span></code>.</p>
<p><strong>Note</strong>: Let <code class="docutils literal notranslate"><span class="pre">DV</span> <span class="pre">=</span> <span class="pre">DFromV&lt;V&gt;</span></code>. For built-in <code class="docutils literal notranslate"><span class="pre">V</span></code> (currently
necessary on RVV/SVE), <code class="docutils literal notranslate"><span class="pre">DV</span></code> might not be the same as the <code class="docutils literal notranslate"><span class="pre">D</span></code> used to
create <code class="docutils literal notranslate"><span class="pre">V</span></code>. In particular, <code class="docutils literal notranslate"><span class="pre">DV</span></code> must not be passed to <code class="docutils literal notranslate"><span class="pre">Load/Store</span></code>
functions because it may lack the limit on <code class="docutils literal notranslate"><span class="pre">N</span></code> established by the
original <code class="docutils literal notranslate"><span class="pre">D</span></code>. However, <code class="docutils literal notranslate"><span class="pre">Vec&lt;DV&gt;</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">V</span></code>.</p>
<p>Thus a template argument <code class="docutils literal notranslate"><span class="pre">V</span></code> suffices for generic functions that do
not load from/store to memory:
<code class="docutils literal notranslate"><span class="pre">template&lt;class</span> <span class="pre">V&gt;</span> <span class="pre">V</span> <span class="pre">Mul4(V</span> <span class="pre">v)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">Mul(v,</span> <span class="pre">Set(DFromV&lt;V&gt;(),</span> <span class="pre">4));</span> <span class="pre">}</span></code>.</p>
<p>Example of mixing partial vectors with generic functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CappedTag</span><span class="o">&lt;</span><span class="n">int16_t</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">d2</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Mul4</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="n">Store</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Use</span> <span class="n">d2</span><span class="p">,</span> <span class="n">NOT</span> <span class="n">DFromV</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="targets">
<h2>Targets<a class="headerlink" href="#targets" title="Permalink to this heading"></a></h2>
<p>Let <code class="docutils literal notranslate"><span class="pre">Target</span></code> denote an instruction set, one of <code class="docutils literal notranslate"><span class="pre">SCALAR/EMU128</span></code>,
<code class="docutils literal notranslate"><span class="pre">RVV</span></code>, <code class="docutils literal notranslate"><span class="pre">SSE2/SSSE3/SSE4/AVX2/AVX3/AVX3_DL/AVX3_ZEN4/AVX3_SPR</span></code> (x86),
<code class="docutils literal notranslate"><span class="pre">PPC8/PPC9/PPC10</span></code> (POWER), <code class="docutils literal notranslate"><span class="pre">Z14/Z15</span></code> (IBM Z), <code class="docutils literal notranslate"><span class="pre">WASM/WASM_EMU256</span></code>
(WebAssembly),
<code class="docutils literal notranslate"><span class="pre">NEON_WITHOUT_AES/NEON/NEON_BF16/SVE/SVE2/SVE_256/SVE2_128</span></code> (Arm).</p>
<p>Note that x86 CPUs are segmented into dozens of feature flags and
capabilities, which are often used together because they were introduced
in the same CPU (example: AVX2 and FMA). To keep the number of targets
and thus compile time and code size manageable, we define targets as
‘clusters’ of related features. To use <code class="docutils literal notranslate"><span class="pre">HWY_AVX2</span></code>, it is therefore
insufficient to pass -mavx2. For definitions of the clusters, see
<code class="docutils literal notranslate"><span class="pre">kGroup*</span></code> in <code class="docutils literal notranslate"><span class="pre">targets.cc</span></code>. The corresponding Clang/GCC compiler
options to enable them (without -m prefix) are defined by
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET_STR*</span></code> in <code class="docutils literal notranslate"><span class="pre">set_macros-inl.h</span></code>, and also listed as comments
in <a class="reference external" href="https://gcc.godbolt.org/z/rGnjMevKG">https://gcc.godbolt.org/z/rGnjMevKG</a>.</p>
<p>Targets are only used if enabled (i.e. not broken nor disabled).
Baseline targets are those for which the compiler is unconditionally
allowed to generate instructions (implying the target CPU must support
them).</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_STATIC_TARGET</span></code> is the best enabled baseline <code class="docutils literal notranslate"><span class="pre">HWY_Target</span></code>,
and matches <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span></code> in static dispatch mode. This is useful
even in dynamic dispatch mode for deducing and printing the compiler
flags.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_TARGETS</span></code> indicates which targets to generate for dynamic
dispatch, and which headers to include. It is determined by
configuration macros and always includes <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_TARGET</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_SUPPORTED_TARGETS</span></code> is the set of targets available at runtime.
Expands to a literal if only a single target is enabled, or
SupportedTargets().</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span></code>: which <code class="docutils literal notranslate"><span class="pre">HWY_Target</span></code> is currently being compiled.
This is initially identical to <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_TARGET</span></code> and remains so
in static dispatch mode. For dynamic dispatch, this changes before
each re-inclusion and finally reverts to <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_TARGET</span></code>. Can
be used in <code class="docutils literal notranslate"><span class="pre">#if</span></code> expressions to provide an alternative to functions
which are not supported by <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code>.</p>
<p>In particular, for x86 we sometimes wish to specialize functions for
AVX-512 because it provides many new instructions. This can be
accomplished via <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">HWY_TARGET</span> <span class="pre">&lt;=</span> <span class="pre">HWY_AVX3</span></code>, which means AVX-512
or better (e.g. <code class="docutils literal notranslate"><span class="pre">HWY_AVX3_DL</span></code>). This is because numerically lower
targets are better, and no other platform has targets numerically
less than those of x86.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_WANT_SSSE3</span></code>, <code class="docutils literal notranslate"><span class="pre">HWY_WANT_SSE4</span></code>: add SSSE3 and SSE4 to the
baseline even if they are not marked as available by the compiler. On
MSVC, the only ways to enable SSSE3 and SSE4 are defining these, or
enabling AVX.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_VISIT_TARGETS(VISITOR)</span></code> expands to
<code class="docutils literal notranslate"><span class="pre">VISITOR(HWY_AVX2,</span> <span class="pre">N_AVX2)</span></code> for all enabled targets (here: AVX2).
The latter is the namespace name. This can be used to declare
target-specific functions in a header, so that they can be called
from within that namespace without the overhead of an additional
<code class="docutils literal notranslate"><span class="pre">HWY_DYNAMIC_DISPATCH</span></code>. Note that the <code class="docutils literal notranslate"><span class="pre">foreach_targets.h</span></code>
mechanism does not work for that because it must reside in a .cc
file.</p></li>
</ul>
<p>You can detect and influence the set of supported targets:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TargetName(t)</span></code> returns a string literal identifying the single
target <code class="docutils literal notranslate"><span class="pre">t</span></code>, where <code class="docutils literal notranslate"><span class="pre">t</span></code> is typically <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SupportedTargets()</span></code> returns an int64_t bitfield of enabled targets
that are supported on this CPU. The return value may change after
calling <code class="docutils literal notranslate"><span class="pre">DisableTargets</span></code>, but will never be zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_SUPPORTED_TARGETS</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">SupportedTargets()</span></code> but
more efficient if only a single target is enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DisableTargets(b)</span></code> causes subsequent <code class="docutils literal notranslate"><span class="pre">SupportedTargets()</span></code> to not
return target(s) whose bits are set in <code class="docutils literal notranslate"><span class="pre">b</span></code>. This is useful for
disabling specific targets if they are unhelpful or undesirable,
e.g. due to memory bandwidth limitations. The effect is not
cumulative; each call overrides the effect of all previous calls.
Calling with <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">0</span></code> restores the original behavior. Use
<code class="docutils literal notranslate"><span class="pre">SetSupportedTargetsForTest</span></code> instead of this function for
iteratively enabling specific targets for testing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SetSupportedTargetsForTest(b)</span></code> causes subsequent
<code class="docutils literal notranslate"><span class="pre">SupportedTargets</span></code> to return <code class="docutils literal notranslate"><span class="pre">b</span></code>, minus those disabled via
<code class="docutils literal notranslate"><span class="pre">DisableTargets</span></code>. <code class="docutils literal notranslate"><span class="pre">b</span></code> is typically derived from a subset of
<code class="docutils literal notranslate"><span class="pre">SupportedTargets()</span></code>, e.g. each individual bit in order to test
each supported target. Calling with <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">0</span></code> restores the normal
<code class="docutils literal notranslate"><span class="pre">SupportedTargets</span></code> behavior.</p></li>
</ul>
</div>
<div class="section" id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Permalink to this heading"></a></h2>
<p>In the following, the argument or return type <code class="docutils literal notranslate"><span class="pre">V</span></code> denotes a vector
with <code class="docutils literal notranslate"><span class="pre">N</span></code> lanes, and <code class="docutils literal notranslate"><span class="pre">M</span></code> a mask. Operations limited to certain vector
types begin with a constraint of the form <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{prefixes}[{bits}]</span></code>.
The prefixes <code class="docutils literal notranslate"><span class="pre">u,i,f</span></code> denote unsigned, signed, and floating-point
types, and bits indicates the number of bits per lane: 8, 16, 32, or 64.
Any combination of the specified prefixes and bits are allowed.
Abbreviations of the form <code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">=</span> <span class="pre">{u}{32}</span></code> may also be used.</p>
<p>Note that Highway functions reside in <code class="docutils literal notranslate"><span class="pre">hwy::HWY_NAMESPACE</span></code>, whereas
user-defined functions reside in <code class="docutils literal notranslate"><span class="pre">project::[nested]::HWY_NAMESPACE</span></code>.
Highway functions generally take either a <code class="docutils literal notranslate"><span class="pre">D</span></code> or vector/mask argument.
For targets where vectors and masks are defined in namespace <code class="docutils literal notranslate"><span class="pre">hwy</span></code>,
the functions will be found via Argument-Dependent Lookup. However, this
does not work for function templates, and RVV and SVE both use built-in
vectors. Thus portable code must use one of the three following options,
in descending order of preference:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">hn</span> <span class="pre">=</span> <span class="pre">hwy::HWY_NAMESPACE;</span></code> alias used to prefix ops, e.g.
<code class="docutils literal notranslate"><span class="pre">hn::LoadDup128(..)</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">hwy::HWY_NAMESPACE::LoadDup128;</span></code> declarations for each op
used;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">hwy::HWY_NAMESPACE;</span></code> directive. This is generally
discouraged, especially for SIMD code residing in a header.</p></li>
</ul>
<p>Note that overloaded operators were not supported on <code class="docutils literal notranslate"><span class="pre">RVV</span></code> and <code class="docutils literal notranslate"><span class="pre">SVE</span></code>
until recently. Unfortunately, clang’s <code class="docutils literal notranslate"><span class="pre">SVE</span></code> comparison operators
return integer vectors instead of the <code class="docutils literal notranslate"><span class="pre">svbool_t</span></code> type which exists for
this purpose. To ensure your code works on all targets, we recommend
instead using the corresponding equivalents mentioned in our description
of each overloaded operator, especially for comparisons, for example
<code class="docutils literal notranslate"><span class="pre">Lt</span></code> instead of <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code>.</p>
<!-- mdlint off(HTML_FORMAT) --><div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this heading"></a></h3>
<ul>
<li><p>V <strong>Zero</strong>(D): returns N-lane vector with all bits set to 0.</p></li>
<li><p>V <strong>Set</strong>(D, T): returns N-lane vector with all lanes equal to the
given value of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p>V <strong>Undefined</strong>(D): returns uninitialized N-lane vector, e.g. for
use as an output parameter.</p></li>
<li><p>V <strong>Iota</strong>(D, T2): returns N-lane vector where the lane with index
<code class="docutils literal notranslate"><span class="pre">i</span></code> has the given value of type <code class="docutils literal notranslate"><span class="pre">T2</span></code> (the op converts it to T) +
<code class="docutils literal notranslate"><span class="pre">i</span></code>. The least significant lane has index 0. This is useful in
tests for detecting lane-crossing bugs.</p></li>
<li><p>V <strong>SignBit</strong>(D): returns N-lane vector with all lanes set to a
value whose representation has only the most-significant bit set.</p></li>
<li><p>V <strong>Dup128VecFromValues</strong>(D d, T t0, .., T tK): Creates a vector
from <code class="docutils literal notranslate"><span class="pre">K+1</span></code> values, broadcasted to each 128-bit block if
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">&gt;=</span>&#160;&#160;&#160;&#160; <span class="pre">16/sizeof(T)</span></code> is true, where <code class="docutils literal notranslate"><span class="pre">K</span></code> is
<code class="docutils literal notranslate"><span class="pre">16/sizeof(T)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>Dup128VecFromValues returns the following values in each 128-bit
block of the result, with <code class="docutils literal notranslate"><span class="pre">t0</span></code> in the least-significant
(lowest-indexed) lane of each 128-bit block and <code class="docutils literal notranslate"><span class="pre">tK</span></code> in the
most-significant (highest-indexed) lane of each 128-bit block:
<code class="docutils literal notranslate"><span class="pre">{t0,</span> <span class="pre">t1,</span> <span class="pre">...,</span> <span class="pre">tK}</span></code></p>
</li>
<li><p>V <strong>MaskedSetOr</strong>(V no, M m, T a): returns N-lane vector with lane
<code class="docutils literal notranslate"><span class="pre">i</span></code> equal to <code class="docutils literal notranslate"><span class="pre">a</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true else <code class="docutils literal notranslate"><span class="pre">no[i]</span></code>.</p></li>
<li><p>V <strong>MaskedSet</strong>(D d, M m, T a): returns N-lane vector with lane
<code class="docutils literal notranslate"><span class="pre">i</span></code> equal to <code class="docutils literal notranslate"><span class="pre">a</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true else 0.</p></li>
</ul>
</div>
<div class="section" id="getting-setting-lanes">
<h3>Getting/setting lanes<a class="headerlink" href="#getting-setting-lanes" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>T <strong>GetLane</strong>(V): returns lane 0 within <code class="docutils literal notranslate"><span class="pre">V</span></code>. This is useful for
extracting <code class="docutils literal notranslate"><span class="pre">SumOfLanes</span></code> results.</p></li>
</ul>
<p>The following may be slow on some platforms (e.g. x86) and should not be
used in time-critical code:</p>
<ul class="simple">
<li><p>T <strong>ExtractLane</strong>(V, size_t i): returns lane <code class="docutils literal notranslate"><span class="pre">i</span></code> within <code class="docutils literal notranslate"><span class="pre">V</span></code>.
<code class="docutils literal notranslate"><span class="pre">i</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(DFromV&lt;V&gt;()))</span></code>. Potentially slow, it
may be better to store an entire vector to an array and then operate
on its elements.</p></li>
<li><p>V <strong>InsertLane</strong>(V, size_t i, T t): returns a copy of V whose lane
<code class="docutils literal notranslate"><span class="pre">i</span></code> is set to <code class="docutils literal notranslate"><span class="pre">t</span></code>. <code class="docutils literal notranslate"><span class="pre">i</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(DFromV&lt;V&gt;()))</span></code>.
Potentially slow, it may be better set all elements of an aligned
array and then <code class="docutils literal notranslate"><span class="pre">Load</span></code> it.</p></li>
</ul>
</div>
<div class="section" id="getting-setting-blocks">
<h3>Getting/setting blocks<a class="headerlink" href="#getting-setting-blocks" title="Permalink to this heading"></a></h3>
<ul>
<li><p>Vec&lt;BlockDFromD&lt;DFromV&gt;&gt; <strong>ExtractBlock</strong>&lt;int kBlock&gt;(V) : returns
block <code class="docutils literal notranslate"><span class="pre">kBlock</span></code> of V, where <code class="docutils literal notranslate"><span class="pre">kBlock</span></code> is an index to a block that
is <code class="docutils literal notranslate"><span class="pre">HWY_MIN(DFromV&lt;V&gt;().MaxBytes(),</span> <span class="pre">16)</span></code> bytes.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBlock</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">DFromV&lt;V&gt;().MaxBlocks())</span></code>.</p>
</li>
<li><p>V <strong>InsertBlock</strong>&lt;int kBlock&gt;(V v, Vec&lt;BlockDFromD&lt;DFromV&gt;&gt;
blk_to_insert): Inserts <code class="docutils literal notranslate"><span class="pre">blk_to_insert</span></code>, with <code class="docutils literal notranslate"><span class="pre">blk_to_insert[i]</span></code>
inserted into lane <code class="docutils literal notranslate"><span class="pre">kBlock</span> <span class="pre">*</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromV&lt;V&gt;))</span> <span class="pre">+</span> <span class="pre">i</span></code> of the
result vector, if
<code class="docutils literal notranslate"><span class="pre">kBlock</span> <span class="pre">*</span> <span class="pre">16</span> <span class="pre">&lt;</span> <span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromV&lt;V&gt;)</span></code> is true.</p>
<p>Otherwise, returns <code class="docutils literal notranslate"><span class="pre">v</span></code> if <code class="docutils literal notranslate"><span class="pre">kBlock</span> <span class="pre">*</span> <span class="pre">16</span></code> is greater than or equal
to <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromV&lt;V&gt;)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBlock</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">DFromV&lt;V&gt;().MaxBlocks())</span></code>.</p>
</li>
<li><p>size_t <strong>Blocks</strong>(D d): Returns the number of 16-byte blocks if
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;D&gt;)</span></code> is greater than or equal to 16.</p>
<p>Otherwise, returns 1 if <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;D&gt;)</span></code> is less than
16.</p>
</li>
</ul>
</div>
<div class="section" id="printing">
<h3>Printing<a class="headerlink" href="#printing" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>V <strong>Print</strong>(D, const char* caption, V [, size_t lane][, size_t
max_lanes]): prints <code class="docutils literal notranslate"><span class="pre">caption</span></code> followed by up to <code class="docutils literal notranslate"><span class="pre">max_lanes</span></code>
comma-separated lanes from the vector argument, starting at index
<code class="docutils literal notranslate"><span class="pre">lane</span></code>. Defined in hwy/print-inl.h, also available if
hwy/tests/test_util-inl.h has been included.</p></li>
</ul>
</div>
<div class="section" id="tuples">
<h3>Tuples<a class="headerlink" href="#tuples" title="Permalink to this heading"></a></h3>
<p>As a partial workaround to the “no vectors as class members” compiler
limitation mentioned in “Using unspecified vector types”, we provide
special types able to carry 2, 3 or 4 vectors, denoted <code class="docutils literal notranslate"><span class="pre">Tuple{2-4}</span></code>
below. Their type is unspecified, potentially built-in, so use the
aliases <code class="docutils literal notranslate"><span class="pre">Vec{2-4}&lt;D&gt;</span></code>. These can (only) be passed as arguments or
returned from functions, and created/accessed using the functions in
this section.</p>
<ul class="simple">
<li><p>Tuple2 <strong>Create2</strong>(D, V v0, V v1): returns tuple such that
<code class="docutils literal notranslate"><span class="pre">Get2&lt;1&gt;(tuple)</span></code> returns <code class="docutils literal notranslate"><span class="pre">v1</span></code>.</p></li>
<li><p>Tuple3 <strong>Create3</strong>(D, V v0, V v1, V v2): returns tuple such that
<code class="docutils literal notranslate"><span class="pre">Get3&lt;2&gt;(tuple)</span></code> returns <code class="docutils literal notranslate"><span class="pre">v2</span></code>.</p></li>
<li><p>Tuple4 <strong>Create4</strong>(D, V v0, V v1, V v2, V v3): returns tuple such
that <code class="docutils literal notranslate"><span class="pre">Get4&lt;3&gt;(tuple)</span></code> returns <code class="docutils literal notranslate"><span class="pre">v3</span></code>.</p></li>
</ul>
<p>The following take a <code class="docutils literal notranslate"><span class="pre">size_t</span></code> template argument indicating the
zero-based index, from left to right, of the arguments passed to
<code class="docutils literal notranslate"><span class="pre">Create{2-4}</span></code>.</p>
<ul class="simple">
<li><p>V <strong>Get2&lt;size_t&gt;</strong>(Tuple2): returns the i-th vector passed to
<code class="docutils literal notranslate"><span class="pre">Create2</span></code>.</p></li>
<li><p>V <strong>Get3&lt;size_t&gt;</strong>(Tuple3): returns the i-th vector passed to
<code class="docutils literal notranslate"><span class="pre">Create3</span></code>.</p></li>
<li><p>V <strong>Get4&lt;size_t&gt;</strong>(Tuple4): returns the i-th vector passed to
<code class="docutils literal notranslate"><span class="pre">Create4</span></code>.</p></li>
<li><p>Tuple2 <strong>Set2&lt;size_t&gt;</strong>(Tuple2 tuple, Vec v): sets the i-th vector</p></li>
<li><p>Tuple3 <strong>Set3&lt;size_t&gt;</strong>(Tuple3 tuple, Vec v): sets the i-th vector</p></li>
<li><p>Tuple4 <strong>Set4&lt;size_t&gt;</strong>(Tuple4 tuple, Vec v): sets the i-th vector</p></li>
</ul>
</div>
<div class="section" id="arithmetic">
<h3>Arithmetic<a class="headerlink" href="#arithmetic" title="Permalink to this heading"></a></h3>
<ul>
<li><p>V <strong>operator+</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> (mod 2^bits).
Currently unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Add</span></code> instead.</p></li>
<li><p>V <strong>operator-</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code> (mod 2^bits).
Currently unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Sub</span></code> instead.</p></li>
<li><p>V <strong>AddSub</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code> in the even lanes
and <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> in the odd lanes.</p>
<p><code class="docutils literal notranslate"><span class="pre">AddSub(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">OddEven(Add(a,</span> <span class="pre">b),</span> <span class="pre">Sub(a,</span> <span class="pre">b))</span></code>
or <code class="docutils literal notranslate"><span class="pre">Add(a,</span> <span class="pre">OddEven(b,</span> <span class="pre">Neg(b)))</span></code>, but <code class="docutils literal notranslate"><span class="pre">AddSub(a,</span> <span class="pre">b)</span></code> is more
efficient than <code class="docutils literal notranslate"><span class="pre">OddEven(Add(a,</span> <span class="pre">b),</span> <span class="pre">Sub(a,</span> <span class="pre">b))</span></code> or
<code class="docutils literal notranslate"><span class="pre">Add(a,</span> <span class="pre">OddEven(b,</span> <span class="pre">Neg(b)))</span></code> on some targets.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>Neg</strong>(V a): returns <code class="docutils literal notranslate"><span class="pre">-a[i]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">i</span></code></div>
<div class="line">V <strong>SaturatedNeg</strong>(V a): returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;T&gt;()</span> <span class="pre">?</span>&#160;&#160;&#160;&#160; <span class="pre">LimitsMax&lt;T&gt;()</span> <span class="pre">:</span> <span class="pre">-a[i]</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SaturatedNeg(a)</span></code> is usually more efficient than
<code class="docutils literal notranslate"><span class="pre">IfThenElse(Eq(a,</span> <span class="pre">Set(d,</span> <span class="pre">LimitsMin&lt;T&gt;())),</span> <span class="pre">Set(d,</span> <span class="pre">LimitsMax&lt;T&gt;()),</span> <span class="pre">Neg(a))</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>Abs</strong>(V a) returns the absolute value of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>; for
integers, <code class="docutils literal notranslate"><span class="pre">LimitsMin()</span></code> maps to <code class="docutils literal notranslate"><span class="pre">LimitsMax()</span> <span class="pre">+</span> <span class="pre">1</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">i</span></code></div>
<div class="line">V <strong>SaturatedAbs</strong>(V a) returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;T&gt;()</span> <span class="pre">?</span>&#160;&#160;&#160;&#160; <span class="pre">LimitsMax&lt;T&gt;()</span> <span class="pre">:</span> <span class="pre">(a[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">(-a[i])</span> <span class="pre">:</span> <span class="pre">a[i])</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SaturatedAbs(a)</span></code> is usually more efficient than
<code class="docutils literal notranslate"><span class="pre">IfThenElse(Eq(a,</span> <span class="pre">Set(d,</span> <span class="pre">LimitsMin&lt;T&gt;())),</span> <span class="pre">Set(d,</span> <span class="pre">LimitsMax&lt;T&gt;()),</span> <span class="pre">Abs(a))</span></code>.</p>
</li>
<li><p>V <strong>AbsDiff</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">|a[i]</span> <span class="pre">-</span> <span class="pre">b[i]|</span></code> in each lane.</p></li>
<li><p>V <strong>PairwiseAdd</strong>(D d, V a, V b): Add consecutive pairs of
elements. Return the results of a and b interleaved, such that
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span>&#160;&#160;&#160;&#160; <span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">a[i+1]</span></code> for even lanes and
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">b[i-1]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> for odd lanes.</p></li>
<li><p>V <strong>PairwiseSub</strong>(D d, V a, V b): Subtract consecutive pairs of
elements. Return the results of a and b interleaved, such that
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span>&#160;&#160;&#160;&#160; <span class="pre">a[i+1]</span> <span class="pre">-</span> <span class="pre">a[i]</span></code> for even lanes and
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">b[i]</span> <span class="pre">-</span> <span class="pre">b[i-1]</span></code> for odd lanes.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}{8,16,32},f{16,32}</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>:
<code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWide&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOf2</strong>(V v) returns the sums of 2 consecutive lanes,
promoting each sum into a lane of <code class="docutils literal notranslate"><span class="pre">TFromV&lt;VW&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}{8,16}</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>:
<code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWideX2&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOf4</strong>(V v) returns the sums of 4 consecutive lanes,
promoting each sum into a lane of <code class="docutils literal notranslate"><span class="pre">TFromV&lt;VW&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}8</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWideX3&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOf8</strong>(V v) returns the sums of 8 consecutive lanes,
promoting each sum into a lane of <code class="docutils literal notranslate"><span class="pre">TFromV&lt;VW&gt;</span></code>. This is slower on
RVV/WASM.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}8</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWideX3&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOf8AbsDiff</strong>(V a, V b) returns the same result as
<code class="docutils literal notranslate"><span class="pre">SumsOf8(AbsDiff(a,</span> <span class="pre">b))</span></code>, but is more efficient on x86.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}8</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWide&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOfAdjQuadAbsDiff</strong>&lt;int kAOffset, int kBOffset&gt;(V a, V b)
returns the sums of the absolute differences of 32-bit blocks of
8-bit integers, widened to <code class="docutils literal notranslate"><span class="pre">MakeWide&lt;TFromV&lt;V&gt;&gt;</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kAOffset</span></code> must be between <code class="docutils literal notranslate"><span class="pre">0</span></code> and
<code class="docutils literal notranslate"><span class="pre">HWY_MIN(1,</span> <span class="pre">(HWY_MAX_LANES_D(DFromV&lt;V&gt;)</span> <span class="pre">-</span> <span class="pre">1)/4)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBOffset</span></code> must be between <code class="docutils literal notranslate"><span class="pre">0</span></code> and
<code class="docutils literal notranslate"><span class="pre">HWY_MIN(3,</span> <span class="pre">(HWY_MAX_LANES_D(DFromV&lt;V&gt;)</span> <span class="pre">-</span> <span class="pre">1)/4)</span></code>.</p>
<p>SumsOfAdjQuadAbsDiff computes
<code class="docutils literal notranslate"><span class="pre">|a[a_idx]</span> <span class="pre">-</span> <span class="pre">b[b_idx]|</span> <span class="pre">+</span> <span class="pre">|a[a_idx+1]</span> <span class="pre">-</span> <span class="pre">b[b_idx+1]|</span> <span class="pre">+</span> <span class="pre">|a[a_idx+2]</span> <span class="pre">-</span> <span class="pre">b[b_idx+2]|</span> <span class="pre">+</span> <span class="pre">|a[a_idx+3]</span> <span class="pre">-</span> <span class="pre">b[b_idx+3]|</span></code>
for each lane <code class="docutils literal notranslate"><span class="pre">i</span></code> of the result, where <code class="docutils literal notranslate"><span class="pre">a_idx</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">kAOffset*4+((i/8)*16)+(i&amp;7)</span></code> and where <code class="docutils literal notranslate"><span class="pre">b_idx</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">kBOffset*4+((i/8)*16)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">&lt;</span> <span class="pre">(8</span> <span class="pre">&lt;&lt;</span> <span class="pre">kAOffset)</span></code> is true, then
SumsOfAdjQuadAbsDiff returns implementation-defined values in any
lanes past the first (lowest-indexed) lane of the result vector.</p>
<p>SumsOfAdjQuadAbsDiff is only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,u}8</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWide&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VW <strong>SumsOfShuffledQuadAbsDiff</strong>&lt;int kIdx3, int kIdx2, int kIdx1,
int kIdx0&gt;(V a, V b) first shuffles <code class="docutils literal notranslate"><span class="pre">a</span></code> as if by the
<code class="docutils literal notranslate"><span class="pre">Per4LaneBlockShuffle&lt;kIdx3,</span> <span class="pre">kIdx2,</span> <span class="pre">kIdx1,</span> <span class="pre">kIdx0&gt;(BitCast(</span>&#160;&#160;&#160;&#160; <span class="pre">RepartitionToWideX2&lt;DFromV&lt;V&gt;&gt;(),</span> <span class="pre">a))</span></code>
operation, and then computes the sum of absolute differences of
32-bit blocks of 8-bit integers taken from the shuffled <code class="docutils literal notranslate"><span class="pre">a</span></code>
vector and the <code class="docutils literal notranslate"><span class="pre">b</span></code> vector.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kIdx0</span></code>, <code class="docutils literal notranslate"><span class="pre">kIdx1</span></code>, <code class="docutils literal notranslate"><span class="pre">kIdx2</span></code>, and <code class="docutils literal notranslate"><span class="pre">kIdx3</span></code> must be between 0 and
3.</p>
<p>SumsOfShuffledQuadAbsDiff computes
<code class="docutils literal notranslate"><span class="pre">|a_shuf[a_idx]</span> <span class="pre">-</span> <span class="pre">b[b_idx]|</span> <span class="pre">+</span> <span class="pre">|a_shuf[a_idx+1]</span> <span class="pre">-</span> <span class="pre">b[b_idx+1]|</span> <span class="pre">+</span> <span class="pre">|a_shuf[a_idx+2]</span> <span class="pre">-</span> <span class="pre">b[b_idx+2]|</span> <span class="pre">+</span> <span class="pre">|a_shuf[a_idx+3]</span> <span class="pre">-</span> <span class="pre">b[b_idx+3]|</span></code>
for each lane <code class="docutils literal notranslate"><span class="pre">i</span></code> of the result, where <code class="docutils literal notranslate"><span class="pre">a_shuf</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">BitCast(DFromV&lt;V&gt;(),</span> <span class="pre">Per4LaneBlockShuffle&lt;kIdx3,</span> <span class="pre">kIdx2,</span> <span class="pre">kIdx1,</span> <span class="pre">kIdx0&gt;(BitCast(RepartitionToWideX2&lt;DFromV&lt;V&gt;&gt;(),</span> <span class="pre">a))</span></code>,
<code class="docutils literal notranslate"><span class="pre">a_idx</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">(i/4)*8+(i&amp;3)</span></code>, and <code class="docutils literal notranslate"><span class="pre">b_idx</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">(i/2)*4</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">&lt;</span> <span class="pre">16</span></code> is true, SumsOfShuffledQuadAbsDiff
returns implementation-defined results in any lanes where
<code class="docutils literal notranslate"><span class="pre">(i/4)*8+(i&amp;3)+3</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(d)</span></code>.</p>
<p>The results of SumsOfAdjQuadAbsDiff are implementation-defined if
<code class="docutils literal notranslate"><span class="pre">kIdx0</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">/</span> <span class="pre">4</span></code>.</p>
<p>The results of any lanes past the first (lowest-indexed) lane of
SumsOfAdjQuadAbsDiff are implementation-defined if
<code class="docutils literal notranslate"><span class="pre">kIdx1</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">/</span> <span class="pre">4</span></code>.</p>
<p>SumsOfShuffledQuadAbsDiff is only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>SaturatedAdd</strong>(V a, V b) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> saturated to
the minimum/maximum representable value.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>SaturatedSub</strong>(V a, V b) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code> saturated to
the minimum/maximum representable value.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>AverageRound</strong>(V a, V b) returns <code class="docutils literal notranslate"><span class="pre">(a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code>.</div>
</div>
</li>
<li><p>V <strong>Clamp</strong>(V a, V lo, V hi): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> clamped to
<code class="docutils literal notranslate"><span class="pre">[lo[i],</span> <span class="pre">hi[i]]</span></code>.</p></li>
<li><p>V <strong>operator/</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">/</span> <span class="pre">b[i]</span></code> in each lane.
Currently unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Div</span></code> instead.</p>
<p>For integer vectors, <code class="docutils literal notranslate"><span class="pre">Div(a,</span> <span class="pre">b)</span></code> returns an implementation-defined
value in any lanes where <code class="docutils literal notranslate"><span class="pre">b[i]</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>For signed integer vectors, <code class="docutils literal notranslate"><span class="pre">Div(a,</span> <span class="pre">b)</span></code> returns an
implementation-defined value in any lanes where
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;T&gt;()</span> <span class="pre">&amp;&amp;</span> <span class="pre">b[i]</span> <span class="pre">==</span> <span class="pre">-1</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator%</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">b[i]</span></code> in each lane.
Currently unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Mod</span></code>
instead.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Mod(a,</span> <span class="pre">b)</span></code> returns an implementation-defined value in any lanes
where <code class="docutils literal notranslate"><span class="pre">b[i]</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>For signed integer vectors, <code class="docutils literal notranslate"><span class="pre">Mod(a,</span> <span class="pre">b)</span></code> returns an
implementation-defined value in any lanes where
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;T&gt;()</span> <span class="pre">&amp;&amp;</span> <span class="pre">b[i]</span> <span class="pre">==</span> <span class="pre">-1</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>Sqrt</strong>(V a): returns <code class="docutils literal notranslate"><span class="pre">sqrt(a[i])</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>ApproximateReciprocalSqrt</strong>(V a): returns an approximation of
<code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">sqrt(a[i])</span></code>.
<code class="docutils literal notranslate"><span class="pre">sqrt(a)</span> <span class="pre">~=</span> <span class="pre">ApproximateReciprocalSqrt(a)</span> <span class="pre">*</span> <span class="pre">a</span></code>. x86 and PPC
provide 12-bit approximations but the error on Arm is closer to 1%.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>ApproximateReciprocal</strong>(V a): returns an approximation of
<code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">a[i]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>GetExponent</strong>(V v): returns the exponent of <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> as a
floating-point value. Essentially calculates <code class="docutils literal notranslate"><span class="pre">floor(log2(x))</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>, <code class="docutils literal notranslate"><span class="pre">VU</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToUnsigned&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">VU <strong>GetBiasedExponent</strong>(V v): returns the biased exponent of
<code class="docutils literal notranslate"><span class="pre">v[i]</span></code> as an unsigned integer value.</div>
</div>
</li>
</ul>
<div class="section" id="min-max">
<h4>Min/Max<a class="headerlink" href="#min-max" title="Permalink to this heading"></a></h4>
<p><strong>Note</strong>: Min/Max corner cases are target-specific and may change. If
either argument is qNaN, x86 SIMD returns the second argument, Armv7
Neon returns NaN, Wasm is supposed to return NaN but does not always,
but other targets actually uphold IEEE 754-2019 minimumNumber: returning
the other argument if exactly one is qNaN, and NaN if both are.</p>
<ul>
<li><p>V <strong>Min</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">min(a[i],</span> <span class="pre">b[i])</span></code>.</p></li>
<li><p>V <strong>Max</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">max(a[i],</span> <span class="pre">b[i])</span></code>.</p></li>
<li><p>V <strong>MinNumber</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">min(a[i],</span> <span class="pre">b[i])</span></code> if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>
and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN.</p>
<p>If one of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is qNaN and the other value is
non-NaN, <code class="docutils literal notranslate"><span class="pre">MinNumber(a,</span> <span class="pre">b)</span></code> returns the non-NaN value.</p>
<p>If one of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is sNaN and the other value is
non-NaN, it is implementation-defined whether <code class="docutils literal notranslate"><span class="pre">MinNumber(a,</span> <span class="pre">b)</span></code>
returns <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code>.</p>
<p>Otherwise, if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both NaN, <code class="docutils literal notranslate"><span class="pre">MinNumber(a,</span> <span class="pre">b)</span></code>
returns NaN.</p>
</li>
<li><p>V <strong>MaxNumber</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">max(a[i],</span> <span class="pre">b[i])</span></code> if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>
and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN.</p>
<p>If one of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is qNaN and the other value is
non-NaN, <code class="docutils literal notranslate"><span class="pre">MaxNumber(a,</span> <span class="pre">b)</span></code> returns the non-NaN value.</p>
<p>If one of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is sNaN and the other value is
non-NaN, it is implementation-defined whether <code class="docutils literal notranslate"><span class="pre">MaxNumber(a,</span> <span class="pre">b)</span></code>
returns <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code>.</p>
<p>Otherwise, if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both NaN, <code class="docutils literal notranslate"><span class="pre">MaxNumber(a,</span> <span class="pre">b)</span></code>
returns NaN.</p>
</li>
<li><p>V <strong>MinMagnitude</strong>(V a, V b): returns the number with the smaller
magnitude if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN, <code class="docutils literal notranslate"><span class="pre">MinMagnitude(a,</span> <span class="pre">b)</span></code>
returns
<code class="docutils literal notranslate"><span class="pre">(|a[i]|</span> <span class="pre">&lt;</span> <span class="pre">|b[i]|</span> <span class="pre">||</span> <span class="pre">(|a[i]|</span> <span class="pre">==</span> <span class="pre">|b[i]|</span> <span class="pre">&amp;&amp;</span> <span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">b[i]))</span> <span class="pre">?</span> <span class="pre">a[i]</span> <span class="pre">:</span> <span class="pre">b[i]</span></code>.</p>
<p>Otherwise, the results of <code class="docutils literal notranslate"><span class="pre">MinMagnitude(a,</span> <span class="pre">b)</span></code> are
implementation-defined if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is NaN or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is NaN.</p>
</li>
<li><p>V <strong>MaxMagnitude</strong>(V a, V b): returns the number with the larger
magnitude if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN values.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> are both non-NaN, <code class="docutils literal notranslate"><span class="pre">MaxMagnitude(a,</span> <span class="pre">b)</span></code>
returns
<code class="docutils literal notranslate"><span class="pre">(|a[i]|</span> <span class="pre">&lt;</span> <span class="pre">|b[i]|</span> <span class="pre">||</span> <span class="pre">(|a[i]|</span> <span class="pre">==</span> <span class="pre">|b[i]|</span> <span class="pre">&amp;&amp;</span> <span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">b[i]))</span> <span class="pre">?</span> <span class="pre">b[i]</span> <span class="pre">:</span> <span class="pre">a[i]</span></code>.</p>
<p>Otherwise, the results of <code class="docutils literal notranslate"><span class="pre">MaxMagnitude(a,</span> <span class="pre">b)</span></code> are
implementation-defined if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is NaN or <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is NaN.</p>
</li>
</ul>
<p>All other ops in this section are only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>Min128</strong>(D, V a, V b): returns the minimum of unsigned
128-bit values, each stored as an adjacent pair of 64-bit lanes
(e.g. indices 1 and 0, where 0 is the least-significant 64-bits).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>Max128</strong>(D, V a, V b): returns the maximum of unsigned
128-bit values, each stored as an adjacent pair of 64-bit lanes
(e.g. indices 1 and 0, where 0 is the least-significant 64-bits).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>Min128Upper</strong>(D, V a, V b): for each 128-bit key-value pair,
returns <code class="docutils literal notranslate"><span class="pre">a</span></code> if it is considered less than <code class="docutils literal notranslate"><span class="pre">b</span></code> by Lt128Upper,
else <code class="docutils literal notranslate"><span class="pre">b</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>Max128Upper</strong>(D, V a, V b): for each 128-bit key-value pair,
returns <code class="docutils literal notranslate"><span class="pre">a</span></code> if it is considered &gt; <code class="docutils literal notranslate"><span class="pre">b</span></code> by Lt128Upper, else
<code class="docutils literal notranslate"><span class="pre">b</span></code>.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="multiply">
<h4>Multiply<a class="headerlink" href="#multiply" title="Permalink to this heading"></a></h4>
<ul>
<li><p>V operator*(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code>, truncating it
to the lower half for integer inputs. Currently unavailable on
SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Mul</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code> V <strong>MulRound</strong>(V a, V b): Multiplies <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> by
<code class="docutils literal notranslate"><span class="pre">b[i]</span></code> and rounds the result to the nearest int with ties going to
even.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">VI</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToSigned&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">V <strong>MulByPow2</strong>(V a, VI b): Multiplies <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> by <code class="docutils literal notranslate"><span class="pre">2^b[i]</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MulByPow2(a,</span> <span class="pre">b)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">std::ldexp(a[i],</span> <span class="pre">HWY_MIN(HWY_MAX(b[i],</span> <span class="pre">LimitsMin&lt;int&gt;()),</span> <span class="pre">LimitsMax&lt;int&gt;()))</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code> V <strong>MulByFloorPow2</strong>(V a, V b): Multiplies <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> by
<code class="docutils literal notranslate"><span class="pre">2^floor(b[i])</span></code>.</p>
<p>It is implementation-defined if <code class="docutils literal notranslate"><span class="pre">MulByFloorPow2(a,</span> <span class="pre">b)</span></code> returns zero
or NaN in any lanes where <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is NaN and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is equal to
negative infinity.</p>
<p>It is implementation-defined if <code class="docutils literal notranslate"><span class="pre">MulByFloorPow2(a,</span> <span class="pre">b)</span></code> returns
positive infinity or NaN in any lanes where <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is NaN and
<code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is equal to positive infinity.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is a non-NaN value and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is equal to negative
infinity, <code class="docutils literal notranslate"><span class="pre">MulByFloorPow2(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">0.0</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is NaN or if <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is non-NaN and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is positive
infinity, <code class="docutils literal notranslate"><span class="pre">MulByFloorPow2(a,</span> <span class="pre">b)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> is a finite value, <code class="docutils literal notranslate"><span class="pre">MulByFloorPow2(a,</span> <span class="pre">b)</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">MulByPow2(a,</span> <span class="pre">FloorInt(b))</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MulHigh</strong>(V a, V b): returns the upper half of
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span></code> in each lane.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">i16</span></code></div>
<div class="line">V <strong>MulFixedPoint15</strong>(V a, V b): returns the result of
multiplying two Q1.15 fixed-point numbers. This corresponds to
doubling the multiplication result and storing the upper half.
Results are implementation-defined iff both inputs are -32768.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V2 <strong>MulEven</strong>(V a, V b): returns double-wide result of
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span></code> for every even <code class="docutils literal notranslate"><span class="pre">i</span></code>, in lanes <code class="docutils literal notranslate"><span class="pre">i</span></code> (lower)
and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code> (upper). <code class="docutils literal notranslate"><span class="pre">V2</span></code> is a vector with double-width lanes,
or the same as <code class="docutils literal notranslate"><span class="pre">V</span></code> for 64-bit inputs (which are only supported if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MulOdd</strong>(V a, V b): returns double-wide result of
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span></code> for every odd <code class="docutils literal notranslate"><span class="pre">i</span></code>, in lanes <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code> (lower)
and <code class="docutils literal notranslate"><span class="pre">i</span></code> (upper). Only supported if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{bf,u,i}16</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>WidenMulPairwiseAdd</strong>(D d, V a, V b): widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">a[2*i+1]*b[2*i+1]</span> <span class="pre">+</span> <span class="pre">a[2*i+0]*b[2*i+0]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">VI</span></code>: <code class="docutils literal notranslate"><span class="pre">i8</span></code>, <code class="docutils literal notranslate"><span class="pre">VU</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToUnsigned&lt;DFromV&lt;VI&gt;&gt;&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">DI</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;VI&gt;&gt;</span></code></div>
<div class="line">Vec&lt;DI&gt; <strong>SatWidenMulPairwiseAdd</strong>(DI di, VU a_u, VI b_i) :
widens <code class="docutils literal notranslate"><span class="pre">a_u</span></code> and <code class="docutils literal notranslate"><span class="pre">b_i</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DI&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">a_u[2*i+1]*b_i[2*i+1]</span> <span class="pre">+</span> <span class="pre">a_u[2*i+0]*b_i[2*i+0]</span></code>, saturated to the
range of <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">DW</span></code>: <code class="docutils literal notranslate"><span class="pre">i32</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">Rebind&lt;MakeNarrow&lt;TFromD&lt;DW&gt;&gt;,</span> <span class="pre">DW&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;DW&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>SatWidenMulPairwiseAccumulate</strong>(DW, V a, V b, VW sum) :
widens <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DI&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">a[2*i]*b[2*i]</span> <span class="pre">+</span> <span class="pre">a[2*i+1]*b[2*i+1]</span> <span class="pre">+</span> <span class="pre">sum[i]</span></code>, saturated to the
range of <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DW&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">DW</span></code>: <code class="docutils literal notranslate"><span class="pre">i32</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">Rebind&lt;MakeNarrow&lt;TFromD&lt;DW&gt;&gt;,</span> <span class="pre">DW&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;DW&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code></div>
<div class="line">VW <strong>SatWidenMulAccumFixedPoint</strong>(DW, V a, V b, VW sum)**:
First, widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DW&gt;</span></code>, then adds
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">*</span> <span class="pre">2</span></code> to <code class="docutils literal notranslate"><span class="pre">sum[i]</span></code>, saturated to the range of
<code class="docutils literal notranslate"><span class="pre">TFromD&lt;DW&gt;</span></code>.</div>
</div>
<p>If
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;TFromD&lt;D&gt;&gt;()</span> <span class="pre">&amp;&amp;</span> <span class="pre">b[i]</span> <span class="pre">==</span> <span class="pre">LimitsMin&lt;TFromD&lt;D&gt;&gt;()</span></code>,
it is implementation-defined whether <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">*</span> <span class="pre">2</span></code> is first
saturated to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DW&gt;</span></code> prior to the addition of
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">*</span> <span class="pre">2</span></code> to <code class="docutils literal notranslate"><span class="pre">sum[i]</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{bf,u,i}16</span></code>, <code class="docutils literal notranslate"><span class="pre">DW</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;DW&gt;</span></code></div>
<div class="line">VW <strong>ReorderWidenMulAccumulate</strong>(DW d, V a, V b, VW sum0, VW&amp;
sum1): widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DW&gt;</span></code>, then adds
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code> to either <code class="docutils literal notranslate"><span class="pre">sum1[j]</span></code> or lane <code class="docutils literal notranslate"><span class="pre">j</span></code> of the return
value, where <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">P(i)</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> is a permutation. The only
guarantee is that <code class="docutils literal notranslate"><span class="pre">SumOfLanes(d,</span>&#160;&#160;&#160;&#160; <span class="pre">Add(return_value,</span> <span class="pre">sum1))</span></code> is
the sum of all <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code>. This is useful for computing dot
products and the L2 norm. The initial value of <code class="docutils literal notranslate"><span class="pre">sum1</span></code> before any
call to <code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code> must be zero (because it is
unused on some platforms). It is safe to set the initial value of
<code class="docutils literal notranslate"><span class="pre">sum0</span></code> to any vector <code class="docutils literal notranslate"><span class="pre">v</span></code>; this has the effect of increasing the
total sum by <code class="docutils literal notranslate"><span class="pre">GetLane(SumOfLanes(d,</span> <span class="pre">v))</span></code> and may be slightly more
efficient than later adding <code class="docutils literal notranslate"><span class="pre">v</span></code> to <code class="docutils literal notranslate"><span class="pre">sum0</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">{f,u,i}32</span></code></div>
<div class="line">VW <strong>RearrangeToOddPlusEven</strong>(VW sum0, VW sum1): returns in each
32-bit lane with index <code class="docutils literal notranslate"><span class="pre">i</span></code>
<code class="docutils literal notranslate"><span class="pre">a[2*i+1]*b[2*i+1]</span> <span class="pre">+</span> <span class="pre">a[2*i+0]*b[2*i+0]</span></code>. <code class="docutils literal notranslate"><span class="pre">sum0</span></code> must be the
return value of a prior <code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum1</span></code>
must be its last (output) argument. In other words, this
strengthens the invariant of <code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code> such
that each 32-bit lane is the sum of the widened products whose
16-bit inputs came from the top and bottom halves of the 32-bit
lane. This is typically called after a series of calls to
<code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code>, as opposed to after each one.
Exception: if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">==</span> <span class="pre">HWY_SCALAR</span></code>, returns <code class="docutils literal notranslate"><span class="pre">a[0]*b[0]</span></code>.
Note that the initial value of <code class="docutils literal notranslate"><span class="pre">sum1</span></code> must be zero, see
<code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">VN</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWideX2&lt;DFromV&lt;VN&gt;&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>SumOfMulQuadAccumulate</strong>(D d, VN a, VN b, Vec&lt;D&gt; sum):
widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">sum[i]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">a[4*i+3]*b[4*i+3]</span> <span class="pre">+</span> <span class="pre">a[4*i+2]*b[4*i+2]</span> <span class="pre">+</span> <span class="pre">a[4*i+1]*b[4*i+1]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">a[4*i+0]*b[4*i+0]</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">VN_I</span></code>: <code class="docutils literal notranslate"><span class="pre">i8</span></code>, <code class="docutils literal notranslate"><span class="pre">VN_U</span></code>:
<code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToUnsigned&lt;DFromV&lt;VN_I&gt;&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">DI</span></code>:
<code class="docutils literal notranslate"><span class="pre">Repartition&lt;int32_t,</span> <span class="pre">DFromV&lt;VN_I&gt;&gt;</span></code></div>
<div class="line">Vec&lt;DI&gt; <strong>SumOfMulQuadAccumulate</strong>(DI di, VN_U a_u, VN_I b_i,
Vec&lt;DI&gt; sum): widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DI&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">sum[i]</span> <span class="pre">+</span> <span class="pre">a[4*i+3]*b[4*i+3]</span> <span class="pre">+</span> <span class="pre">a[4*i+2]*b[4*i+2]</span> <span class="pre">+</span> <span class="pre">a[4*i+1]*b[4*i+1]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">a[4*i+0]*b[4*i+0]</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16,32},{f}16</span></code>,</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">VW</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">VW</span> <span class="pre">**WidenMulAccumulate**(D,</span> <span class="pre">V</span> <span class="pre">a,</span> <span class="pre">V</span> <span class="pre">b,</span> <span class="pre">VW</span> <span class="pre">low,</span> <span class="pre">VW&amp;</span> <span class="pre">high)</span></code>:
widens <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, multiplies them together, then adds them to
<code class="docutils literal notranslate"><span class="pre">Combine(Twice&lt;D&gt;(),</span> <span class="pre">high,</span>&#160;&#160;&#160;&#160; <span class="pre">low)</span></code>. Returns the lower half of
the result, and sets high to the upper half.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="fused-multiply-add">
<h4>Fused multiply-add<a class="headerlink" href="#fused-multiply-add" title="Permalink to this heading"></a></h4>
<p>When implemented using special instructions, these functions are more
precise and faster than separate multiplication followed by addition.
The <code class="docutils literal notranslate"><span class="pre">*Sub</span></code> variants are somewhat slower on Arm, and unavailable for
integer inputs; if the <code class="docutils literal notranslate"><span class="pre">c</span></code> argument is a constant, it would be better
to negate it and use <code class="docutils literal notranslate"><span class="pre">MulAdd</span></code>.</p>
<ul>
<li><p>V <strong>MulAdd</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">c[i]</span></code>.</p></li>
<li><p>V <strong>NegMulAdd</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">-a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">c[i]</span></code>.</p></li>
<li><p>V <strong>MulSub</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">-</span> <span class="pre">c[i]</span></code>.</p></li>
<li><p>V <strong>NegMulSub</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">-a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">-</span> <span class="pre">c[i]</span></code>.</p></li>
<li><p>V <strong>MulAddSub</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">-</span> <span class="pre">c[i]</span></code> in
the even lanes and <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">c[i]</span></code> in the odd lanes.</p>
<p><code class="docutils literal notranslate"><span class="pre">MulAddSub(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">OddEven(MulAdd(a,</span> <span class="pre">b,</span> <span class="pre">c),</span> <span class="pre">MulSub(a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> or
<code class="docutils literal notranslate"><span class="pre">MulAddSub(a,</span> <span class="pre">b,</span> <span class="pre">OddEven(c,</span> <span class="pre">Neg(c))</span></code>, but <code class="docutils literal notranslate"><span class="pre">MulSub(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is
more efficient on some targets (including AVX2/AVX3).</p>
</li>
<li><p>V <strong>MulSubAdd</strong>(V a, V b, V c): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">c[i]</span></code> in
the even lanes and <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">-</span> <span class="pre">c[i]</span></code> in the odd lanes.
Essentially, MulAddSub with <code class="docutils literal notranslate"><span class="pre">c[i]</span></code> negated.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">bf16</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>:
<code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code></div>
<div class="line">VW <strong>MulEvenAdd</strong>(D d, V a, V b, VW c): equivalent to and
potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">MulAdd(PromoteEvenTo(d,</span> <span class="pre">a),</span>&#160;&#160;&#160;&#160; <span class="pre">PromoteEvenTo(d,</span> <span class="pre">b),</span> <span class="pre">c)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">bf16</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">VW</span></code>:
<code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code></div>
<div class="line">VW <strong>MulOddAdd</strong>(D d, V a, V b, VW c): equivalent to and
potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">MulAdd(PromoteOddTo(d,</span> <span class="pre">a),</span> <span class="pre">PromoteOddTo(d,</span>&#160;&#160;&#160;&#160; <span class="pre">b),</span> <span class="pre">c)</span></code>.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="masked-arithmetic">
<h4>Masked arithmetic<a class="headerlink" href="#masked-arithmetic" title="Permalink to this heading"></a></h4>
<p>All ops in this section return <code class="docutils literal notranslate"><span class="pre">no</span></code> for <code class="docutils literal notranslate"><span class="pre">mask=false</span></code> lanes, and
suppress any exceptions for those lanes if that is supported by the ISA.
When exceptions are not a concern, these are equivalent to, and
potentially more efficient than, <code class="docutils literal notranslate"><span class="pre">IfThenElse(m,</span> <span class="pre">Add(a,</span> <span class="pre">b),</span> <span class="pre">no);</span></code> etc.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>MaskedSqrtOr</strong>(V no, M m, V a): returns <code class="docutils literal notranslate"><span class="pre">sqrt(a[i])</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><p>V <strong>MaskedMinOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">Min(a,</span> <span class="pre">b)[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedMaxOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">Max(a,</span> <span class="pre">b)[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedAddOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedSubOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedMulOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedDivOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">/</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedModOr</strong>(V no, M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">b[i]</span></code>
or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>MaskedSatAddOr</strong>(V no, M m, V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span></code> saturated to the minimum/maximum representable
value, or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>MaskedSatSubOr</strong>(V no, M m, V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span></code> saturated to the minimum/maximum representable
value, or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><p>V <strong>MaskedMulAddOr</strong>(V no, M m, V mul, V x, V add): returns
<code class="docutils literal notranslate"><span class="pre">mul[i]</span> <span class="pre">*</span> <span class="pre">x[i]</span> <span class="pre">+</span> <span class="pre">add[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>MaskedAbsOr</strong>(V no, M m, V a): returns the absolute value of
<code class="docutils literal notranslate"><span class="pre">a[i]</span></code> where m is active and returns <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> otherwise.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="zero-masked-arithmetic">
<h4>Zero masked arithmetic<a class="headerlink" href="#zero-masked-arithmetic" title="Permalink to this heading"></a></h4>
<p>All ops in this section return <code class="docutils literal notranslate"><span class="pre">0</span></code> for <code class="docutils literal notranslate"><span class="pre">mask=false</span></code> lanes. These are
equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">IfThenElseZero(m,</span> <span class="pre">Add(a,</span> <span class="pre">b));</span></code> etc.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>MaskedAbs</strong>(M m, V a): returns the absolute value of <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>
where m is active and returns zero otherwise.</div>
</div>
</li>
<li><p>V <strong>MaskedMax</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">Max(a,</span> <span class="pre">b)[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">zero</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedAdd</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedSub</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedMul</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedDiv</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">/</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>MaskedSaturatedAdd</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">b[i]</span></code>
saturated to the minimum/maximum representable value, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16}</span></code></div>
<div class="line">V <strong>MaskedSaturatedSub</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">-</span> <span class="pre">b[i]</span></code>
saturated to the minimum/maximum representable value, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">i16</span></code></div>
<div class="line">V <strong>MaskedMulFixedPoint15</strong>(M m, V a, V b): returns returns the
result of multiplying two Q1.15 fixed-point numbers, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</div>
</div>
</li>
<li><p>V <strong>MaskedMulAdd</strong>(M m, V a, V b, V c): returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[i]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">c[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>V <strong>MaskedNegMulAdd</strong>(M m, V a, V b, V c): returns
<code class="docutils literal notranslate"><span class="pre">-a[i]</span> <span class="pre">*</span>&#160;&#160;&#160;&#160; <span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">c[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{bf,u,i}16</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>MaskedWidenMulPairwiseAdd</strong>(D d, M m, V a, V b): widens
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code> and computes
<code class="docutils literal notranslate"><span class="pre">a[2*i+1]*b[2*i+1]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">a[2*i+0]*b[2*i+0]</span></code>, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code>
is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>MaskedSqrt</strong>(M m, V a): returns <code class="docutils literal notranslate"><span class="pre">sqrt(a[i])</span></code> where m is
true, and zero otherwise.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>MaskedApproximateReciprocalSqrt</strong>(M m, V a): returns the
result of ApproximateReciprocalSqrt where m is true and zero
otherwise.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>MaskedApproximateReciprocal</strong>(M m, V a): returns the result
of ApproximateReciprocal where m is true and zero otherwise.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="complex-number-operations">
<h4>Complex number operations<a class="headerlink" href="#complex-number-operations" title="Permalink to this heading"></a></h4>
<p>Complex types are represented as complex value pairs of real and
imaginary components, with the real components in even-indexed lanes and
the imaginary components in odd-indexed lanes.</p>
<p>All multiplies in this section are performing complex multiplication,
i.e. <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">ib)(c</span> <span class="pre">+</span> <span class="pre">id)</span></code>.</p>
<p>Take <code class="docutils literal notranslate"><span class="pre">j</span></code> to be the even values of <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>ComplexConj</strong>(V v): returns the complex conjugate of the
vector, this negates the imaginary lanes. This is equivalent to
<code class="docutils literal notranslate"><span class="pre">OddEven(Neg(a),</span> <span class="pre">a)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MulComplex</strong>(V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span> <span class="pre">i.a[j</span> <span class="pre">+</span> <span class="pre">1])(b[j]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MulComplexConj</strong>(V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span> <span class="pre">i.a[j</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">1])(b[j]</span> <span class="pre">-</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MulComplexAdd</strong>(V a, V b, V c): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span> <span class="pre">i.a[j</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">1])(b[j]</span> <span class="pre">+</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span> <span class="pre">+</span> <span class="pre">(c[j]</span> <span class="pre">+</span> <span class="pre">i.c[j</span> <span class="pre">+</span> <span class="pre">1])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MulComplexConjAdd</strong>(V a, V b, V c): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">i.a[j</span> <span class="pre">+</span> <span class="pre">1])(b[j]</span> <span class="pre">-</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span> <span class="pre">+</span> <span class="pre">(c[j]</span> <span class="pre">+</span> <span class="pre">i.c[j</span> <span class="pre">+</span> <span class="pre">1])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MaskedMulComplexConjAdd</strong>(M mask, V a, V b, V c): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span> <span class="pre">i.a[j</span> <span class="pre">+</span> <span class="pre">1])(b[j]</span> <span class="pre">-</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span> <span class="pre">+</span> <span class="pre">(c[j]</span> <span class="pre">+</span> <span class="pre">i.c[j</span> <span class="pre">+</span> <span class="pre">1])</span></code> or
<code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MaskedMulComplexConj</strong>(M mask, V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span>&#160;&#160;&#160;&#160; <span class="pre">i.a[j</span> <span class="pre">+</span> <span class="pre">1])(b[j]</span> <span class="pre">-</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
V <strong>MaskedMulComplexOr</strong>(V no, M mask, V a, V b): returns
<code class="docutils literal notranslate"><span class="pre">(a[j]</span> <span class="pre">+</span> <span class="pre">i.a[j</span> <span class="pre">+</span> <span class="pre">1])(b[j]</span> <span class="pre">+</span> <span class="pre">i.b[j</span> <span class="pre">+</span> <span class="pre">1])</span></code> or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if
<code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</p></li>
</ul>
</div>
<div class="section" id="shifts">
<h4>Shifts<a class="headerlink" href="#shifts" title="Permalink to this heading"></a></h4>
<p><strong>Note</strong>: Counts not in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">sizeof(T)*8)</span></code> yield
implementation-defined results. Left-shifting signed <code class="docutils literal notranslate"><span class="pre">T</span></code> and
right-shifting positive signed <code class="docutils literal notranslate"><span class="pre">T</span></code> is the same as shifting
<code class="docutils literal notranslate"><span class="pre">MakeUnsigned&lt;T&gt;</span></code> and casting to <code class="docutils literal notranslate"><span class="pre">T</span></code>. Right-shifting negative signed
<code class="docutils literal notranslate"><span class="pre">T</span></code> is the same as an unsigned shift, except that 1-bits are shifted
in.</p>
<p>Compile-time constant shifts: the amount must be in [0, sizeof(T)*8).
Generally the most efficient variant, but 8-bit shifts are potentially
slower than other lane sizes, and <code class="docutils literal notranslate"><span class="pre">RotateRight</span></code> is often emulated with
shifts:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftLeft</strong>&lt;int&gt;(V a) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">int</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftRight</strong>&lt;int&gt;(V a) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">int</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RoundingShiftRight</strong>&lt;int&gt;(V a) returns
<code class="docutils literal notranslate"><span class="pre">((int</span> <span class="pre">==</span> <span class="pre">0)</span> <span class="pre">?</span> <span class="pre">a[i]</span> <span class="pre">:</span> <span class="pre">(((a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">(int</span> <span class="pre">-</span> <span class="pre">1))</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;&gt;</span> <span class="pre">1)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RotateLeft</strong>&lt;int&gt;(V a) returns
<code class="docutils literal notranslate"><span class="pre">(a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">int)</span> <span class="pre">|</span>&#160;&#160;&#160;&#160; <span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span> <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">int))</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RotateRight</strong>&lt;int&gt;(V a) returns
<code class="docutils literal notranslate"><span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span> <span class="pre">int)</span> <span class="pre">|</span> <span class="pre">(a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">int))</span></code>.</div>
</div>
</li>
</ul>
<p>Shift all lanes by the same (not necessarily compile-time constant)
amount:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftLeftSame</strong>(V a, int bits) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">bits</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftRightSame</strong>(V a, int bits) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">bits</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RoundingShiftRightSame</strong>&lt;int kShiftAmt&gt;(V a, int bits)
returns
<code class="docutils literal notranslate"><span class="pre">((bits</span> <span class="pre">==</span> <span class="pre">0)</span> <span class="pre">?</span> <span class="pre">a[i]</span> <span class="pre">:</span> <span class="pre">(((a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">(bits</span> <span class="pre">-</span> <span class="pre">1))</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;&gt;</span> <span class="pre">1)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RotateLeftSame</strong>(V a, int bits) returns
<code class="docutils literal notranslate"><span class="pre">(a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">shl_bits)</span> <span class="pre">|</span> <span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span>&#160;&#160;&#160;&#160; <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">shl_bits))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">shl_bits</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&amp;</span> <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RotateRightSame</strong>(V a, int bits) returns
<code class="docutils literal notranslate"><span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span> <span class="pre">shr_bits)</span> <span class="pre">|</span> <span class="pre">(a[i]</span> <span class="pre">&gt;&gt;</span>&#160;&#160;&#160;&#160; <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">shr_bits))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">shr_bits</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&amp;</span> <span class="pre">(sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</div>
</div>
</li>
</ul>
<p>Per-lane variable shifts (slow if SSSE3/SSE4, or 16-bit, or Shr i64 on
AVX2):</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator&lt;&lt;</strong>(V a, V b) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Shl</span></code> instead.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator&gt;&gt;</strong>(V a, V b) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Shr</span></code> instead.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>RoundingShr</strong>(V a, V b) returns
<code class="docutils literal notranslate"><span class="pre">((b[i]</span> <span class="pre">==</span> <span class="pre">0)</span> <span class="pre">?</span> <span class="pre">a[i]</span> <span class="pre">:</span> <span class="pre">(((a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">(b[i]</span> <span class="pre">-</span> <span class="pre">1))</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">&gt;&gt;</span> <span class="pre">1)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>Rol</strong>(V a, V b) returns
<code class="docutils literal notranslate"><span class="pre">(a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">(b[i]</span> <span class="pre">&amp;</span> <span class="pre">shift_amt_mask))</span> <span class="pre">|</span>&#160;&#160;&#160;&#160; <span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span> <span class="pre">((sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">b[i])</span> <span class="pre">&amp;</span> <span class="pre">shift_amt_mask))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">shift_amt_mask</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">1</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>Ror</strong>(V a, V b) returns
<code class="docutils literal notranslate"><span class="pre">(static_cast&lt;TU&gt;(a[i])</span> <span class="pre">&gt;&gt;</span> <span class="pre">(b[i]</span> <span class="pre">&amp;</span> <span class="pre">shift_amt_mask))</span> <span class="pre">|</span>&#160;&#160;&#160;&#160; <span class="pre">(a[i]</span> <span class="pre">&lt;&lt;</span> <span class="pre">((sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">b[i])</span> <span class="pre">&amp;</span> <span class="pre">shift_amt_mask))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">shift_amt_mask</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">sizeof(T)*8</span> <span class="pre">-</span> <span class="pre">1</span></code>.</div>
</div>
</li>
</ul>
<p>A compound shift on 64-bit values:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}64</span></code>, <code class="docutils literal notranslate"><span class="pre">VI</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}8</span></code></div>
<div class="line">V <strong>MultiRotateRight</strong>(V vals, VI indices): returns a vector with
<code class="docutils literal notranslate"><span class="pre">(vals[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">indices[i*8+j])</span> <span class="pre">&amp;</span> <span class="pre">0xff</span></code> in byte <code class="docutils literal notranslate"><span class="pre">j</span></code> of vector
<code class="docutils literal notranslate"><span class="pre">r[i]</span></code> for each <code class="docutils literal notranslate"><span class="pre">j</span></code> between 0 and 7.</div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">indices[i*8+j]</span></code> is less than 0 or greater than 63, byte <code class="docutils literal notranslate"><span class="pre">j</span></code>
of <code class="docutils literal notranslate"><span class="pre">r[i]</span></code> is implementation-defined.</p>
<p><code class="docutils literal notranslate"><span class="pre">VI</span></code> must be either <code class="docutils literal notranslate"><span class="pre">Vec&lt;Repartition&lt;int8_t,</span> <span class="pre">DFromV&lt;V&gt;&gt;&gt;</span></code> or
<code class="docutils literal notranslate"><span class="pre">Vec&lt;Repartition&lt;uint8_t,</span> <span class="pre">DFromV&lt;V&gt;&gt;&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MultiRotateRight(V</span> <span class="pre">vals,</span> <span class="pre">VI</span> <span class="pre">indices)</span></code> is equivalent to the
following loop (where <code class="docutils literal notranslate"><span class="pre">N</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint64_t</span> <span class="n">shift_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">rot_result</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">|</span>
      <span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="o">-</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">));</span>
<span class="c1">#if HWY_IS_LITTLE_ENDIAN</span>
    <span class="n">shift_result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rot_result</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="c1">#else</span>
    <span class="n">shift_result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">rot_result</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">j</span> <span class="o">^</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="c1">#endif</span>
  <span class="p">}</span>
  <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift_result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="masked-shifts">
<h4>Masked Shifts<a class="headerlink" href="#masked-shifts" title="Permalink to this heading"></a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedShiftLeft</strong>&lt;int&gt;(M mask, V a) returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;&lt;</span>&#160;&#160;&#160;&#160; <span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedShiftRight</strong>&lt;int&gt;(M mask, V a) returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span>&#160;&#160;&#160;&#160; <span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedShiftRightOr</strong>&lt;int&gt;(V no, M mask, V a) returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedShrOr</strong>(V no, M mask, V a, V shifts) returns
<code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;&gt;</span>&#160;&#160;&#160;&#160; <span class="pre">shifts[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">no[i]</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is false.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="floating-point-rounding">
<h4>Floating-point rounding<a class="headerlink" href="#floating-point-rounding" title="Permalink to this heading"></a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>Round</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> rounded towards the nearest
integer, with ties to even.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>Trunc</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> rounded towards zero
(truncate).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>Ceil</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> rounded towards positive
infinity (ceiling).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>Floor</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> rounded towards negative
infinity.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="floating-point-classification">
<h4>Floating-point classification<a class="headerlink" href="#floating-point-classification" title="Permalink to this heading"></a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">M <strong>IsNaN</strong>(V v): returns mask indicating whether <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is
“not a number” (unordered).</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">M <strong>IsEitherNaN</strong>(V a, V b): equivalent to
<code class="docutils literal notranslate"><span class="pre">Or(IsNaN(a),</span> <span class="pre">IsNaN(b))</span></code>, but <code class="docutils literal notranslate"><span class="pre">IsEitherNaN(a,</span> <span class="pre">b)</span></code> is more
efficient than <code class="docutils literal notranslate"><span class="pre">Or(IsNaN(a),</span> <span class="pre">IsNaN(b))</span></code> on x86.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">M <strong>IsInf</strong>(V v): returns mask indicating whether <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is
positive or negative infinity.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">M <strong>IsFinite</strong>(V v): returns mask indicating whether <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is
neither NaN nor infinity, i.e. normal, subnormal or zero.
Equivalent to <code class="docutils literal notranslate"><span class="pre">Not(Or(IsNaN(v),</span> <span class="pre">IsInf(v)))</span></code>.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="masked-floating-point-classification">
<h4>Masked floating-point classification<a class="headerlink" href="#masked-floating-point-classification" title="Permalink to this heading"></a></h4>
<p>All ops in this section return <code class="docutils literal notranslate"><span class="pre">false</span></code> for <code class="docutils literal notranslate"><span class="pre">mask=false</span></code> lanes. These
are equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">And(m,</span> <span class="pre">IsNaN(v));</span></code> etc.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code>
M <strong>MaskedIsNaN</strong>(M m, V v): returns mask indicating whether
<code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is “not a number” (unordered) or <code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is
false.</p></li>
</ul>
</div>
</div>
<div class="section" id="logical">
<h3>Logical<a class="headerlink" href="#logical" title="Permalink to this heading"></a></h3>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>PopulationCount</strong>(V a): returns the number of 1-bits in each
lane, i.e. <code class="docutils literal notranslate"><span class="pre">PopCount(a[i])</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>LeadingZeroCount</strong>(V a): returns the number of leading zeros
in each lane. For any lanes where <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is zero,
<code class="docutils literal notranslate"><span class="pre">sizeof(TFromV&lt;V&gt;)</span> <span class="pre">*</span> <span class="pre">8</span></code> is returned in the corresponding result
lanes.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>MaskedLeadingZeroCount</strong>(M m, V a): returns the result of
LeadingZeroCount where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true, and zero otherwise.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>TrailingZeroCount</strong>(V a): returns the number of trailing
zeros in each lane. For any lanes where <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is zero,
<code class="docutils literal notranslate"><span class="pre">sizeof(TFromV&lt;V&gt;)</span> <span class="pre">*</span> <span class="pre">8</span></code> is returned in the corresponding result
lanes.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>HighestSetBitIndex</strong>(V a): returns the index of the highest
set bit of each lane. For any lanes of a signed vector type where
<code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is zero, an unspecified negative value is returned in the
corresponding result lanes. For any lanes of an unsigned vector
type where <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> is zero, an unspecified value that is greater
than <code class="docutils literal notranslate"><span class="pre">HighestValue&lt;MakeSigned&lt;TFromV&lt;V&gt;&gt;&gt;()</span></code> is returned in the
corresponding result lanes.</div>
</div>
</li>
<li><p>bool <strong>AllBits1</strong>(D, V v): returns whether all bits are set.</p></li>
<li><p>bool <strong>AllBits0</strong>(D, V v): returns whether all bits are clear.</p></li>
</ul>
<p>The following operate on individual bits within each lane. Note that the
non-operator functions (<code class="docutils literal notranslate"><span class="pre">And</span></code> instead of <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) must be used for
floating-point types, and on SVE/RVV.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator&amp;</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&amp;</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">And</span></code> instead.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator|</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">|</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Or</span></code> instead.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>operator^</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">^</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Xor</span></code> instead.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>Not</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">~v[i]</span></code>.</div>
</div>
</li>
<li><p>V <strong>AndNot</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">~a[i]</span> <span class="pre">&amp;</span> <span class="pre">b[i]</span></code>.</p></li>
<li><p>V <strong>MaskedOr</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">|</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">zero</span></code>
if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
</ul>
<p>The following three-argument functions may be more efficient than
assembling them from 2-argument functions:</p>
<ul class="simple">
<li><p>V <strong>Xor3</strong>(V x1, V x2, V x3): returns <code class="docutils literal notranslate"><span class="pre">x1[i]</span> <span class="pre">^</span> <span class="pre">x2[i]</span> <span class="pre">^</span> <span class="pre">x3[i]</span></code>.
This is more efficient than <code class="docutils literal notranslate"><span class="pre">Or3</span></code> on some targets. When inputs are
disjoint (no bit is set in more than one argument), <code class="docutils literal notranslate"><span class="pre">Xor3</span></code> and
<code class="docutils literal notranslate"><span class="pre">Or3</span></code> are equivalent and you should use the former.</p></li>
<li><p>V <strong>Or3</strong>(V o1, V o2, V o3): returns <code class="docutils literal notranslate"><span class="pre">o1[i]</span> <span class="pre">|</span> <span class="pre">o2[i]</span> <span class="pre">|</span> <span class="pre">o3[i]</span></code>.
This is less efficient than <code class="docutils literal notranslate"><span class="pre">Xor3</span></code> on some targets; use that where
possible.</p></li>
<li><p>V <strong>OrAnd</strong>(V o, V a1, V a2): returns <code class="docutils literal notranslate"><span class="pre">o[i]</span> <span class="pre">|</span> <span class="pre">(a1[i]</span> <span class="pre">&amp;</span> <span class="pre">a2[i])</span></code>.</p></li>
<li><p>V <strong>XorAndNot</strong>(V x, V a1, V a2): returns
<code class="docutils literal notranslate"><span class="pre">x[i]</span> <span class="pre">^</span> <span class="pre">(~a1[i]</span> <span class="pre">&amp;</span>&#160;&#160;&#160;&#160; <span class="pre">a2[i])</span></code>. This is useful for conditionally
flipping bits.</p></li>
<li><p>V <strong>BitwiseIfThenElse</strong>(V mask, V yes, V no): returns
<code class="docutils literal notranslate"><span class="pre">((mask[i]</span> <span class="pre">&amp;</span> <span class="pre">yes[i])</span> <span class="pre">|</span> <span class="pre">(~mask[i]</span> <span class="pre">&amp;</span> <span class="pre">no[i]))</span></code>. <code class="docutils literal notranslate"><span class="pre">BitwiseIfThenElse</span></code>
is equivalent to, but potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">Or(And(mask,</span> <span class="pre">yes),</span>&#160;&#160;&#160;&#160; <span class="pre">AndNot(mask,</span> <span class="pre">no))</span></code>.</p></li>
</ul>
<p>Special functions for signed types:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>CopySign</strong>(V a, V b): returns the number with the magnitude
of <code class="docutils literal notranslate"><span class="pre">a</span></code> and sign of <code class="docutils literal notranslate"><span class="pre">b</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">V <strong>CopySignToAbs</strong>(V a, V b): as above, but potentially slightly
more efficient; requires the first argument to be non-negative.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i}</span></code></div>
<div class="line">V <strong>BroadcastSignBit</strong>(V a) returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">-1</span> <span class="pre">:</span> <span class="pre">0</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>ZeroIfNegative</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">0</span> <span class="pre">:</span> <span class="pre">v[i]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>IfNegativeThenElse</strong>(V v, V yes, V no): returns
<code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span>&#160;&#160;&#160;&#160; <span class="pre">yes[i]</span> <span class="pre">:</span> <span class="pre">no[i]</span></code>. This may be more efficient than
<code class="docutils literal notranslate"><span class="pre">IfThenElse(Lt..)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>IfNegativeThenElseZero</strong>(V v, V yes): returns
<code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">yes[i]</span> <span class="pre">:</span> <span class="pre">0</span></code>. <code class="docutils literal notranslate"><span class="pre">IfNegativeThenElseZero(v,</span> <span class="pre">yes)</span></code> is
equivalent to but more efficient than
<code class="docutils literal notranslate"><span class="pre">IfThenElseZero(IsNegative(v),</span> <span class="pre">yes)</span></code> or
<code class="docutils literal notranslate"><span class="pre">IfNegativeThenElse(v,</span> <span class="pre">yes,</span> <span class="pre">Zero(d))</span></code> on some targets.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>IfNegativeThenZeroElse</strong>(V v, V no): returns
<code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">0</span> <span class="pre">:</span> <span class="pre">no</span></code>. <code class="docutils literal notranslate"><span class="pre">IfNegativeThenZeroElse(v,</span> <span class="pre">no)</span></code> is
equivalent to but more efficient than
<code class="docutils literal notranslate"><span class="pre">IfThenZeroElse(IsNegative(v),</span> <span class="pre">no)</span></code> or
<code class="docutils literal notranslate"><span class="pre">IfNegativeThenElse(v,</span> <span class="pre">Zero(d),</span> <span class="pre">no)</span></code> on some targets.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">V <strong>IfNegativeThenNegOrUndefIfZero</strong>(V mask, V v): returns
<code class="docutils literal notranslate"><span class="pre">mask[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">(-v[i])</span> <span class="pre">:</span> <span class="pre">((mask[i]</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">?</span> <span class="pre">v[i]</span> <span class="pre">:</span> <span class="pre">impl_defined_val)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">impl_defined_val</span></code> is an implementation-defined value that
is equal to either 0 or <code class="docutils literal notranslate"><span class="pre">v[i]</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IfNegativeThenNegOrUndefIfZero(mask,</span> <span class="pre">v)</span></code> is more efficient than
<code class="docutils literal notranslate"><span class="pre">IfNegativeThenElse(mask,</span> <span class="pre">Neg(v),</span> <span class="pre">v)</span></code> for I8/I16/I32 vectors that
are 32 bytes or smaller on SSSE3/SSE4/AVX2/AVX3 targets.</p>
</li>
</ul>
</div>
<div class="section" id="masks">
<h3>Masks<a class="headerlink" href="#masks" title="Permalink to this heading"></a></h3>
<p>Let <code class="docutils literal notranslate"><span class="pre">M</span></code> denote a mask capable of storing a logical true/false for each
lane (the encoding depends on the platform).</p>
<div class="section" id="create-mask">
<h4>Create mask<a class="headerlink" href="#create-mask" title="Permalink to this heading"></a></h4>
<ul>
<li><p>M <strong>FirstN</strong>(D, size_t N): returns mask with the first <code class="docutils literal notranslate"><span class="pre">N</span></code> lanes
(those with index <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">N</span></code>) true. <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(D())</span></code> results in an
all-true mask. <code class="docutils literal notranslate"><span class="pre">N</span></code> must not exceed
<code class="docutils literal notranslate"><span class="pre">LimitsMax&lt;SignedFromSize&lt;HWY_MIN(sizeof(size_t),</span> <span class="pre">sizeof(TFromD&lt;D&gt;))&gt;&gt;()</span></code>.
Useful for implementing “masked” stores by loading <code class="docutils literal notranslate"><span class="pre">prev</span></code> followed
by <code class="docutils literal notranslate"><span class="pre">IfThenElse(FirstN(d,</span> <span class="pre">N),</span> <span class="pre">what_to_store,</span> <span class="pre">prev)</span></code>.</p></li>
<li><p>M <strong>MaskFromVec</strong>(V v): returns false in lane <code class="docutils literal notranslate"><span class="pre">i</span></code> if
<code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">==</span>&#160;&#160;&#160;&#160; <span class="pre">0</span></code>, or true if <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> has all bits set. The result
is <em>implementation-defined</em> if <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> is neither zero nor all bits
set.</p></li>
<li><p>M <strong>LoadMaskBits</strong>(D, const uint8_t* p): returns a mask indicating
whether the i-th bit in the array is set. Loads bytes and bits in
ascending order of address and index. At least 8 bytes of <code class="docutils literal notranslate"><span class="pre">p</span></code> must
be readable, but only <code class="docutils literal notranslate"><span class="pre">(Lanes(D())</span> <span class="pre">+</span> <span class="pre">7)</span> <span class="pre">/</span> <span class="pre">8</span></code> need be initialized.
Any unused bits (happens if <code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">&lt;</span> <span class="pre">8</span></code>) are treated as if
they were zero.</p></li>
<li><p>M <strong>Dup128MaskFromMaskBits</strong>(D d, unsigned mask_bits): returns a
mask with lane <code class="docutils literal notranslate"><span class="pre">i</span></code> set to
<code class="docutils literal notranslate"><span class="pre">((mask_bits</span> <span class="pre">&gt;&gt;</span> <span class="pre">(i</span> <span class="pre">&amp;</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(T)</span> <span class="pre">-</span> <span class="pre">1)))</span> <span class="pre">&amp;</span> <span class="pre">1)</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p></li>
<li><p>M <strong>MaskFalse(D)</strong>: returns an all-false mask. <code class="docutils literal notranslate"><span class="pre">MaskFalse(D())</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">MaskFromVec(Zero(D()))</span></code>, but <code class="docutils literal notranslate"><span class="pre">MaskFalse(D())</span></code>
is more efficient than <code class="docutils literal notranslate"><span class="pre">MaskFromVec(Zero(D()))</span></code> on AVX3, RVV, and
SVE.</p>
<p><code class="docutils literal notranslate"><span class="pre">MaskFalse(D())</span></code> is also equivalent to <code class="docutils literal notranslate"><span class="pre">FirstN(D(),</span> <span class="pre">0)</span></code> or
<code class="docutils literal notranslate"><span class="pre">Dup128MaskFromMaskBits(D(),</span> <span class="pre">0)</span></code>, but <code class="docutils literal notranslate"><span class="pre">MaskFalse(D())</span></code> is usually
more efficient.</p>
</li>
<li><p>M <strong>SetMask</strong>(D, bool val): equivalent to
<code class="docutils literal notranslate"><span class="pre">RebindMask(d,</span> <span class="pre">MaskFromVec(Set(RebindToSigned&lt;D&gt;(),</span>&#160;&#160;&#160;&#160; <span class="pre">-static_cast&lt;MakeSigned&lt;TFromD&lt;D&gt;&gt;&gt;(val))))</span></code>,
but <code class="docutils literal notranslate"><span class="pre">SetMask(d,</span> <span class="pre">val)</span></code> is usually more efficient.</p></li>
</ul>
</div>
<div class="section" id="convert-mask">
<h4>Convert mask<a class="headerlink" href="#convert-mask" title="Permalink to this heading"></a></h4>
<ul>
<li><p>M1 <strong>RebindMask</strong>(D, M2 m): returns same mask bits as <code class="docutils literal notranslate"><span class="pre">m</span></code>, but
reinterpreted as a mask for lanes of type <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">M1</span></code> and
<code class="docutils literal notranslate"><span class="pre">M2</span></code> must have the same number of lanes.</p></li>
<li><p>V <strong>VecFromMask</strong>(D, M m): returns 0 in lane <code class="docutils literal notranslate"><span class="pre">i</span></code> if
<code class="docutils literal notranslate"><span class="pre">m[i]</span> <span class="pre">==</span>&#160;&#160;&#160;&#160; <span class="pre">false</span></code>, otherwise all bits set.</p></li>
<li><p>uint64_t <strong>BitsFromMask</strong>(D, M m): returns bits <code class="docutils literal notranslate"><span class="pre">b</span></code> such that
<code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">&gt;&gt;</span> <span class="pre">i)</span> <span class="pre">&amp;</span> <span class="pre">1</span></code> indicates whether <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> was set, and any
remaining bits in the <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> are zero. This is only available
if <code class="docutils literal notranslate"><span class="pre">HWY_MAX_BYTES</span> <span class="pre">&lt;=</span> <span class="pre">64</span></code>, because 512-bit vectors are the longest
for which there are no more than 64 lanes and thus mask bits.</p></li>
<li><p>size_t <strong>StoreMaskBits</strong>(D, M m, uint8_t* p): stores a bit array
indicating whether <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true, in ascending order of <code class="docutils literal notranslate"><span class="pre">i</span></code>,
filling the bits of each byte from least to most significant, then
proceeding to the next byte. Returns the number of bytes written:
<code class="docutils literal notranslate"><span class="pre">(Lanes(D())</span> <span class="pre">+</span> <span class="pre">7)</span> <span class="pre">/</span> <span class="pre">8</span></code>. At least 8 bytes of <code class="docutils literal notranslate"><span class="pre">p</span></code> must be writable.</p></li>
<li><p>Mask&lt;DTo&gt; <strong>PromoteMaskTo</strong>(DTo d_to, DFrom d_from, Mask&lt;DFrom&gt; m):
Promotes <code class="docutils literal notranslate"><span class="pre">m</span></code> to a mask with a lane type of <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DTo&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">DFrom</span></code> is <code class="docutils literal notranslate"><span class="pre">Rebind&lt;TFrom,</span> <span class="pre">DTo&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">PromoteMaskTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(BitCast(d_to,</span> <span class="pre">PromoteTo(di_to,</span> <span class="pre">BitCast(di_from,</span> <span class="pre">VecFromMask(d_from,</span> <span class="pre">m)))))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">di_from</span></code> is <code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DFrom&gt;()</span></code> and <code class="docutils literal notranslate"><span class="pre">di_from</span></code> is
<code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DFrom&gt;()</span></code>, but <code class="docutils literal notranslate"><span class="pre">PromoteMaskTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">m)</span></code>
is more efficient on some targets.</p>
<p>PromoteMaskTo requires that
<code class="docutils literal notranslate"><span class="pre">sizeof(TFromD&lt;DFrom&gt;)</span> <span class="pre">&lt;</span> <span class="pre">sizeof(TFromD&lt;DTo&gt;)</span></code> be true.</p>
</li>
<li><p>Mask&lt;DTo&gt; <strong>DemoteMaskTo</strong>(DTo d_to, DFrom d_from, Mask&lt;DFrom&gt; m):
Demotes <code class="docutils literal notranslate"><span class="pre">m</span></code> to a mask with a lane type of <code class="docutils literal notranslate"><span class="pre">TFromD&lt;DTo&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">DFrom</span></code> is <code class="docutils literal notranslate"><span class="pre">Rebind&lt;TFrom,</span> <span class="pre">DTo&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">DemoteMaskTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(BitCast(d_to,</span> <span class="pre">DemoteTo(di_to,</span> <span class="pre">BitCast(di_from,</span> <span class="pre">VecFromMask(d_from,</span> <span class="pre">m)))))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">di_from</span></code> is <code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DFrom&gt;()</span></code> and <code class="docutils literal notranslate"><span class="pre">di_from</span></code> is
<code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DFrom&gt;()</span></code>, but <code class="docutils literal notranslate"><span class="pre">DemoteMaskTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">m)</span></code> is
more efficient on some targets.</p>
<p>DemoteMaskTo requires that
<code class="docutils literal notranslate"><span class="pre">sizeof(TFromD&lt;DFrom&gt;)</span> <span class="pre">&gt;</span> <span class="pre">sizeof(TFromD&lt;DTo&gt;)</span></code> be true.</p>
</li>
<li><p>M <strong>OrderedDemote2MasksTo</strong>(DTo, DFrom, M2, M2): returns a mask
whose <code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> is the first argument and whose <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code> is
the second argument; <code class="docutils literal notranslate"><span class="pre">M2</span></code> is <code class="docutils literal notranslate"><span class="pre">Mask&lt;Half&lt;DFrom&gt;&gt;</span></code>; <code class="docutils literal notranslate"><span class="pre">DTo</span></code> is
<code class="docutils literal notranslate"><span class="pre">Repartition&lt;TTo,</span> <span class="pre">DFrom&gt;</span></code>.</p>
<p>OrderedDemote2MasksTo requires that
<code class="docutils literal notranslate"><span class="pre">sizeof(TFromD&lt;DTo&gt;)</span> <span class="pre">==</span> <span class="pre">sizeof(TFromD&lt;DFrom&gt;)</span> <span class="pre">*</span> <span class="pre">2</span></code> be true.</p>
<p><code class="docutils literal notranslate"><span class="pre">OrderedDemote2MasksTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(BitCast(d_to,</span> <span class="pre">OrderedDemote2To(di_to,</span> <span class="pre">va,</span> <span class="pre">vb)))</span></code>,
where <code class="docutils literal notranslate"><span class="pre">va</span></code> is <code class="docutils literal notranslate"><span class="pre">BitCast(di_from,</span> <span class="pre">MaskFromVec(d_from,</span> <span class="pre">a))</span></code>, <code class="docutils literal notranslate"><span class="pre">vb</span></code>
is <code class="docutils literal notranslate"><span class="pre">BitCast(di_from,</span> <span class="pre">MaskFromVec(d_from,</span> <span class="pre">b))</span></code>, <code class="docutils literal notranslate"><span class="pre">di_to</span></code> is
<code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DTo&gt;()</span></code>, and <code class="docutils literal notranslate"><span class="pre">di_from</span></code> is
<code class="docutils literal notranslate"><span class="pre">RebindToSigned&lt;DFrom&gt;()</span></code>, but
<code class="docutils literal notranslate"><span class="pre">OrderedDemote2MasksTo(d_to,</span> <span class="pre">d_from,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is more efficient on
some targets.</p>
<p>OrderedDemote2MasksTo is only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code> is true.</p>
</li>
</ul>
</div>
<div class="section" id="combine-mask">
<h4>Combine mask<a class="headerlink" href="#combine-mask" title="Permalink to this heading"></a></h4>
<ul>
<li><p>M2 <strong>LowerHalfOfMask</strong>(D d, M m): returns the lower half of mask
<code class="docutils literal notranslate"><span class="pre">m</span></code>, where <code class="docutils literal notranslate"><span class="pre">M</span></code> is <code class="docutils literal notranslate"><span class="pre">MFromD&lt;Twice&lt;D&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">M2</span></code> is
<code class="docutils literal notranslate"><span class="pre">MFromD&lt;D&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">LowerHalfOfMask(d,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(LowerHalf(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">LowerHalfOfMask(d,</span> <span class="pre">m)</span></code> is more efficient on some targets.</p>
</li>
<li><p>M2 <strong>UpperHalfOfMask</strong>(D d, M m): returns the upper half of mask
<code class="docutils literal notranslate"><span class="pre">m</span></code>, where <code class="docutils literal notranslate"><span class="pre">M</span></code> is <code class="docutils literal notranslate"><span class="pre">MFromD&lt;Twice&lt;D&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">M2</span></code> is
<code class="docutils literal notranslate"><span class="pre">MFromD&lt;D&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">UpperHalfOfMask(d,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(UpperHalf(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">UpperHalfOfMask(d,</span> <span class="pre">m)</span></code> is more efficient on some targets.</p>
<p>UpperHalfOfMask is only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code> is
true.</p>
</li>
<li><p>M <strong>CombineMasks</strong>(D, M2, M2): returns a mask whose <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>
is the first argument and whose <code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> is the second argument;
<code class="docutils literal notranslate"><span class="pre">M2</span></code> is <code class="docutils literal notranslate"><span class="pre">Mask&lt;Half&lt;D&gt;&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">CombineMasks(d,</span> <span class="pre">hi,</span> <span class="pre">lo)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(d,</span> <span class="pre">Combine(d,</span> <span class="pre">VecFromMask(Half&lt;D&gt;(),</span> <span class="pre">hi),</span> <span class="pre">VecFromMask(Half&lt;D&gt;(),</span> <span class="pre">lo)))</span></code>,
but <code class="docutils literal notranslate"><span class="pre">CombineMasks(d,</span> <span class="pre">hi,</span> <span class="pre">lo)</span></code> is more efficient on some targets.</p>
<p>CombineMasks is only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code> is
true.</p>
</li>
</ul>
</div>
<div class="section" id="slide-mask-across-blocks">
<h4>Slide mask across blocks<a class="headerlink" href="#slide-mask-across-blocks" title="Permalink to this heading"></a></h4>
<ul>
<li><p>M <strong>SlideMaskUpLanes</strong>(D d, M m, size_t N): Slides <code class="docutils literal notranslate"><span class="pre">m</span></code> up <code class="docutils literal notranslate"><span class="pre">N</span></code>
lanes. <code class="docutils literal notranslate"><span class="pre">SlideMaskUpLanes(d,</span> <span class="pre">m,</span> <span class="pre">N)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(SlideUpLanes(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m),</span> <span class="pre">N))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideMaskUpLanes(d,</span> <span class="pre">m,</span> <span class="pre">N)</span></code> is more efficient on some targets.</p>
<p>The results of SlideMaskUpLanes is implementation-defined if
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(d)</span></code>.</p>
</li>
<li><p>M <strong>SlideMaskDownLanes</strong>(D d, M m, size_t N): Slides <code class="docutils literal notranslate"><span class="pre">m</span></code> down
<code class="docutils literal notranslate"><span class="pre">N</span></code> lanes. <code class="docutils literal notranslate"><span class="pre">SlideMaskDownLanes(d,</span> <span class="pre">m,</span> <span class="pre">N)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(SlideDownLanes(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m),</span> <span class="pre">N))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideMaskDownLanes(d,</span> <span class="pre">m,</span> <span class="pre">N)</span></code> is more efficient on some targets.</p>
<p>The results of SlideMaskDownLanes is implementation-defined if
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(d)</span></code>.</p>
</li>
<li><p>M <strong>SlideMask1Up</strong>(D d, M m): Slides <code class="docutils literal notranslate"><span class="pre">m</span></code> up 1 lane.
<code class="docutils literal notranslate"><span class="pre">SlideMask1Up(d,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(Slide1Up(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideMask1Up(d,</span> <span class="pre">m)</span></code> is more efficient on some targets.</p></li>
<li><p>M <strong>SlideMask1Down</strong>(D d, M m): Slides <code class="docutils literal notranslate"><span class="pre">m</span></code> down 1 lane.
<code class="docutils literal notranslate"><span class="pre">SlideMask1Down(d,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(Slide1Down(d,</span> <span class="pre">VecFromMask(d,</span> <span class="pre">m)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideMask1Down(d,</span> <span class="pre">m)</span></code> is more efficient on some targets.</p></li>
</ul>
</div>
<div class="section" id="test-mask">
<h4>Test mask<a class="headerlink" href="#test-mask" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>bool <strong>AllTrue</strong>(D, M m): returns whether all <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> are true.</p></li>
<li><p>bool <strong>AllFalse</strong>(D, M m): returns whether all <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> are false.</p></li>
<li><p>size_t <strong>CountTrue</strong>(D, M m): returns how many of <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> are true
[0, N]. This is typically more expensive than AllTrue/False.</p></li>
<li><p>intptr_t <strong>FindFirstTrue</strong>(D, M m): returns the index of the first
(i.e. lowest index) <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> that is true, or -1 if none are.</p></li>
<li><p>size_t <strong>FindKnownFirstTrue</strong>(D, M m): returns the index of the
first (i.e. lowest index) <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> that is true. Requires
<code class="docutils literal notranslate"><span class="pre">!AllFalse(d,</span> <span class="pre">m)</span></code>, otherwise results are undefined. This is
typically more efficient than <code class="docutils literal notranslate"><span class="pre">FindFirstTrue</span></code>.</p></li>
<li><p>intptr_t <strong>FindLastTrue</strong>(D, M m): returns the index of the last
(i.e. highest index) <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> that is true, or -1 if none are.</p></li>
<li><p>size_t <strong>FindKnownLastTrue</strong>(D, M m): returns the index of the last
(i.e. highest index) <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> that is true. Requires
<code class="docutils literal notranslate"><span class="pre">!AllFalse(d,</span> <span class="pre">m)</span></code>, otherwise results are undefined. This is
typically more efficient than <code class="docutils literal notranslate"><span class="pre">FindLastTrue</span></code>.</p></li>
</ul>
</div>
<div class="section" id="ternary-operator-for-masks">
<h4>Ternary operator for masks<a class="headerlink" href="#ternary-operator-for-masks" title="Permalink to this heading"></a></h4>
<p>For <code class="docutils literal notranslate"><span class="pre">IfThen*</span></code>, masks must adhere to the invariant established by
<code class="docutils literal notranslate"><span class="pre">MaskFromVec</span></code>: false is zero, true has all bits set:</p>
<ul class="simple">
<li><p>V <strong>IfThenElse</strong>(M mask, V yes, V no): returns
<code class="docutils literal notranslate"><span class="pre">mask[i]</span> <span class="pre">?</span>&#160;&#160;&#160;&#160; <span class="pre">yes[i]</span> <span class="pre">:</span> <span class="pre">no[i]</span></code>.</p></li>
<li><p>V <strong>IfThenElseZero</strong>(M mask, V yes): returns
<code class="docutils literal notranslate"><span class="pre">mask[i]</span> <span class="pre">?</span>&#160;&#160;&#160;&#160; <span class="pre">yes[i]</span> <span class="pre">:</span> <span class="pre">0</span></code>.</p></li>
<li><p>V <strong>IfThenZeroElse</strong>(M mask, V no): returns
<code class="docutils literal notranslate"><span class="pre">mask[i]</span> <span class="pre">?</span> <span class="pre">0</span> <span class="pre">:</span>&#160;&#160;&#160;&#160; <span class="pre">no[i]</span></code>.</p></li>
<li><p>V <strong>IfVecThenElse</strong>(V mask, V yes, V no): equivalent to and
possibly faster than <code class="docutils literal notranslate"><span class="pre">IfVecThenElse(MaskFromVec(mask),</span> <span class="pre">yes,</span> <span class="pre">no)</span></code>.
The result is <em>implementation-defined</em> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is neither zero
nor all bits set.</p></li>
</ul>
</div>
<div class="section" id="logical-mask">
<h4>Logical mask<a class="headerlink" href="#logical-mask" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>M <strong>Not</strong>(M m): returns mask of elements indicating whether the
input mask element was false.</p></li>
<li><p>M <strong>And</strong>(M a, M b): returns mask of elements indicating whether
both input mask elements were true.</p></li>
<li><p>M <strong>AndNot</strong>(M not_a, M b): returns mask of elements indicating
whether <code class="docutils literal notranslate"><span class="pre">not_a</span></code> is false and <code class="docutils literal notranslate"><span class="pre">b</span></code> is true.</p></li>
<li><p>M <strong>Or</strong>(M a, M b): returns mask of elements indicating whether
either input mask element was true.</p></li>
<li><p>M <strong>Xor</strong>(M a, M b): returns mask of elements indicating whether
exactly one input mask element was true.</p></li>
<li><p>M <strong>ExclusiveNeither</strong>(M a, M b): returns mask of elements
indicating <code class="docutils literal notranslate"><span class="pre">a</span></code> is false and <code class="docutils literal notranslate"><span class="pre">b</span></code> is false. Undefined if both are
true. We choose not to provide NotOr/NotXor because x86 and SVE only
define one of these operations. This op is for situations where the
inputs are known to be mutually exclusive.</p></li>
<li><p>M <strong>SetOnlyFirst</strong>(M m): If none of <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> are true, returns
all-false. Otherwise, only lane <code class="docutils literal notranslate"><span class="pre">k</span></code> is true, where <code class="docutils literal notranslate"><span class="pre">k</span></code> is equal
to <code class="docutils literal notranslate"><span class="pre">FindKnownFirstTrue(m)</span></code>. In other words, sets to false any lanes
with index greater than the first true lane, if it exists.</p></li>
<li><p>M <strong>SetBeforeFirst</strong>(M m): If none of <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> are true, returns
all-true. Otherwise, returns mask with the first <code class="docutils literal notranslate"><span class="pre">k</span></code> lanes true and
all remaining lanes false, where <code class="docutils literal notranslate"><span class="pre">k</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">FindKnownFirstTrue(m)</span></code>. In other words, if at least one of
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true, sets to true any lanes with index less than the
first true lane and all remaining lanes to false.</p></li>
<li><p>M <strong>SetAtOrBeforeFirst</strong>(M m): equivalent to
<code class="docutils literal notranslate"><span class="pre">Or(SetBeforeFirst(m),</span> <span class="pre">SetOnlyFirst(m))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SetAtOrBeforeFirst(m)</span></code> is usually more efficient than
<code class="docutils literal notranslate"><span class="pre">Or(SetBeforeFirst(m),</span> <span class="pre">SetOnlyFirst(m))</span></code>.</p></li>
<li><p>M <strong>SetAtOrAfterFirst</strong>(M m): equivalent to
<code class="docutils literal notranslate"><span class="pre">Not(SetBeforeFirst(m))</span></code>.</p></li>
</ul>
</div>
<div class="section" id="compress">
<h4>Compress<a class="headerlink" href="#compress" title="Permalink to this heading"></a></h4>
<ul>
<li><p>V <strong>Compress</strong>(V v, M m): returns <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">r[n]</span></code> is
<code class="docutils literal notranslate"><span class="pre">v[i]</span></code>, with <code class="docutils literal notranslate"><span class="pre">i</span></code> the n-th lane index (starting from 0) where
<code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is true. Compacts lanes whose mask is true into the lower
lanes. For targets and lane type <code class="docutils literal notranslate"><span class="pre">T</span></code> where
<code class="docutils literal notranslate"><span class="pre">CompressIsPartition&lt;T&gt;::value</span></code> is true, the upper lanes are those
whose mask is false (thus <code class="docutils literal notranslate"><span class="pre">Compress</span></code> corresponds to partitioning
according to the mask). Otherwise, the upper lanes are
implementation-defined. Potentially slow with 8 and 16-bit lanes. Use
this form when the input is already a mask, e.g. returned by a
comparison.</p></li>
<li><p>V <strong>CompressNot</strong>(V v, M m): equivalent to
<code class="docutils literal notranslate"><span class="pre">Compress(v,</span>&#160;&#160;&#160;&#160; <span class="pre">Not(m))</span></code> but possibly faster if
<code class="docutils literal notranslate"><span class="pre">CompressIsPartition&lt;T&gt;::value</span></code> is true.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>CompressBlocksNot</strong>(V v, M m): equivalent to
<code class="docutils literal notranslate"><span class="pre">CompressNot(v,</span> <span class="pre">m)</span></code> when <code class="docutils literal notranslate"><span class="pre">m</span></code> is structured as adjacent pairs
(both true or false), e.g. as returned by <code class="docutils literal notranslate"><span class="pre">Lt128</span></code>. This is a
no-op for 128 bit vectors. Unavailable if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">==</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><p>size_t <strong>CompressStore</strong>(V v, M m, D d, T* p): writes lanes whose
mask <code class="docutils literal notranslate"><span class="pre">m</span></code> is true into <code class="docutils literal notranslate"><span class="pre">p</span></code>, starting from lane 0. Returns
<code class="docutils literal notranslate"><span class="pre">CountTrue(d,</span>&#160;&#160;&#160;&#160; <span class="pre">m)</span></code>, the number of valid lanes. May be
implemented as <code class="docutils literal notranslate"><span class="pre">Compress</span></code> followed by <code class="docutils literal notranslate"><span class="pre">StoreU</span></code>; lanes after the
valid ones may still be overwritten! Potentially slow with 8 and
16-bit lanes.</p></li>
<li><p>size_t <strong>CompressBlendedStore</strong>(V v, M m, D d, T* p): writes only
lanes whose mask <code class="docutils literal notranslate"><span class="pre">m</span></code> is true into <code class="docutils literal notranslate"><span class="pre">p</span></code>, starting from lane 0.
Returns <code class="docutils literal notranslate"><span class="pre">CountTrue(d,</span> <span class="pre">m)</span></code>, the number of lanes written. Does not
modify subsequent lanes, but there is no guarantee of atomicity
because this may be implemented as
<code class="docutils literal notranslate"><span class="pre">Compress,</span> <span class="pre">LoadU,</span> <span class="pre">IfThenElse(FirstN),</span> <span class="pre">StoreU</span></code>.</p></li>
<li><p>V <strong>CompressBits</strong>(V v, const uint8_t* HWY_RESTRICT bits):
Equivalent to, but often faster than
<code class="docutils literal notranslate"><span class="pre">Compress(v,</span> <span class="pre">LoadMaskBits(d,</span> <span class="pre">bits))</span></code>. <code class="docutils literal notranslate"><span class="pre">bits</span></code> is as specified for
<code class="docutils literal notranslate"><span class="pre">LoadMaskBits</span></code>. If called multiple times, the <code class="docutils literal notranslate"><span class="pre">bits</span></code> pointer
passed to this function must also be marked <code class="docutils literal notranslate"><span class="pre">HWY_RESTRICT</span></code> to avoid
repeated work. Note that if the vector has less than 8 elements,
incrementing <code class="docutils literal notranslate"><span class="pre">bits</span></code> will not work as intended for packed bit
arrays. As with <code class="docutils literal notranslate"><span class="pre">Compress</span></code>, <code class="docutils literal notranslate"><span class="pre">CompressIsPartition</span></code> indicates the
mask=false lanes are moved to the upper lanes. Potentially slow with
8 and 16-bit lanes.</p></li>
<li><p>size_t <strong>CompressBitsStore</strong>(V v, const uint8_t* HWY_RESTRICT
bits, D d, T* p): combination of <code class="docutils literal notranslate"><span class="pre">CompressStore</span></code> and
<code class="docutils literal notranslate"><span class="pre">CompressBits</span></code>, see remarks there.</p></li>
</ul>
</div>
<div class="section" id="expand">
<h4>Expand<a class="headerlink" href="#expand" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>V <strong>Expand</strong>(V v, M m): returns <code class="docutils literal notranslate"><span class="pre">r</span></code> such that <code class="docutils literal notranslate"><span class="pre">r[i]</span></code> is zero
where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false, and otherwise <code class="docutils literal notranslate"><span class="pre">v[s]</span></code>, where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the
number of <code class="docutils literal notranslate"><span class="pre">m[0,</span> <span class="pre">i)</span></code> which are true. Scatters inputs in ascending
index order to the lanes whose mask is true and zeros all other
lanes. Potentially slow with 8 and 16-bit lanes.</p></li>
<li><p>V <strong>LoadExpand</strong>(M m, D d, const T* p): returns <code class="docutils literal notranslate"><span class="pre">r</span></code> such that
<code class="docutils literal notranslate"><span class="pre">r[i]</span></code> is zero where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false, and otherwise <code class="docutils literal notranslate"><span class="pre">p[s]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the number of <code class="docutils literal notranslate"><span class="pre">m[0,</span> <span class="pre">i)</span></code> which are true. May be
implemented as <code class="docutils literal notranslate"><span class="pre">LoadU</span></code> followed by <code class="docutils literal notranslate"><span class="pre">Expand</span></code>. Potentially slow
with 8 and 16-bit lanes.</p></li>
</ul>
</div>
</div>
<div class="section" id="comparisons">
<h3>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this heading"></a></h3>
<p>These return a mask (see above) indicating whether the condition is
true.</p>
<ul>
<li><p>M <strong>operator==</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Eq</span></code> instead.</p></li>
<li><p>M <strong>operator!=</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">!=</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Ne</span></code> instead.</p></li>
<li><p>M <strong>operator&lt;</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Lt</span></code> instead.</p></li>
<li><p>M <strong>operator&gt;</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Gt</span></code> instead.</p></li>
<li><p>M <strong>operator&lt;=</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;=</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Le</span></code> instead.</p></li>
<li><p>M <strong>operator&gt;=</strong>(V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;=</span> <span class="pre">b[i]</span></code>. Currently
unavailable on SVE/RVV; use the equivalent <code class="docutils literal notranslate"><span class="pre">Ge</span></code> instead.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{i,f}</span></code></div>
<div class="line">M <strong>IsNegative</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IsNegative(v)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskFromVec(BroadcastSignBit(v))</span></code> or <code class="docutils literal notranslate"><span class="pre">Lt(v,</span> <span class="pre">Zero(d))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">IsNegative(v)</span></code> is more efficient on some targets.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">M <strong>TestBit</strong>(V v, V bit): returns <code class="docutils literal notranslate"><span class="pre">(v[i]</span> <span class="pre">&amp;</span> <span class="pre">bit[i])</span> <span class="pre">==</span> <span class="pre">bit[i]</span></code>.
<code class="docutils literal notranslate"><span class="pre">bit[i]</span></code> must have exactly one bit set.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Lt128</strong>(D, V a, V b): for each adjacent pair of 64-bit lanes
(e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]:a[0]</span></code> concatenated to
an unsigned 128-bit integer (least significant bits in <code class="docutils literal notranslate"><span class="pre">a[0]</span></code>) is
less than <code class="docutils literal notranslate"><span class="pre">b[1]:b[0]</span></code>. For each pair, the mask lanes are either
both true or both false. Unavailable if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">==</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Lt128Upper</strong>(D, V a, V b): for each adjacent pair of 64-bit
lanes (e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]</span></code> is less than
<code class="docutils literal notranslate"><span class="pre">b[1]</span></code>. For each pair, the mask lanes are either both true or
both false. This is useful for comparing 64-bit keys alongside
64-bit values. Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Eq128</strong>(D, V a, V b): for each adjacent pair of 64-bit lanes
(e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]:a[0]</span></code> concatenated to
an unsigned 128-bit integer (least significant bits in <code class="docutils literal notranslate"><span class="pre">a[0]</span></code>)
equals <code class="docutils literal notranslate"><span class="pre">b[1]:b[0]</span></code>. For each pair, the mask lanes are either both
true or both false. Unavailable if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">==</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Ne128</strong>(D, V a, V b): for each adjacent pair of 64-bit lanes
(e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]:a[0]</span></code> concatenated to
an unsigned 128-bit integer (least significant bits in <code class="docutils literal notranslate"><span class="pre">a[0]</span></code>)
differs from <code class="docutils literal notranslate"><span class="pre">b[1]:b[0]</span></code>. For each pair, the mask lanes are
either both true or both false. Unavailable if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">==</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Eq128Upper</strong>(D, V a, V b): for each adjacent pair of 64-bit
lanes (e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]</span></code> equals <code class="docutils literal notranslate"><span class="pre">b[1]</span></code>.
For each pair, the mask lanes are either both true or both false.
This is useful for comparing 64-bit keys alongside 64-bit values.
Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span>&#160;&#160;&#160;&#160; <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">M <strong>Ne128Upper</strong>(D, V a, V b): for each adjacent pair of 64-bit
lanes (e.g. indices 1,0), returns whether <code class="docutils literal notranslate"><span class="pre">a[1]</span></code> differs from
<code class="docutils literal notranslate"><span class="pre">b[1]</span></code>. For each pair, the mask lanes are either both true or
both false. This is useful for comparing 64-bit keys alongside
64-bit values. Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
</ul>
<div class="section" id="masked-comparison">
<h4>Masked comparison<a class="headerlink" href="#masked-comparison" title="Permalink to this heading"></a></h4>
<p>All ops in this section return <code class="docutils literal notranslate"><span class="pre">false</span></code> for <code class="docutils literal notranslate"><span class="pre">mask=false</span></code> lanes. These
are equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">And(m,</span> <span class="pre">Eq(a,</span> <span class="pre">b));</span></code> etc.</p>
<ul class="simple">
<li><p>M <strong>MaskedEq</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">==</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>M <strong>MaskedNe</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">!=</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>M <strong>MaskedLt</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>
if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>M <strong>MaskedGt</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;</span> <span class="pre">b[i]</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>
if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>M <strong>MaskedLe</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&lt;=</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
<li><p>M <strong>MaskedGe</strong>(M m, V a, V b): returns <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">&gt;=</span> <span class="pre">b[i]</span></code> or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is false.</p></li>
</ul>
</div>
</div>
<div class="section" id="memory">
<h3>Memory<a class="headerlink" href="#memory" title="Permalink to this heading"></a></h3>
<p>Memory operands are little-endian, otherwise their order would depend on
the lane configuration. Pointers are the addresses of <code class="docutils literal notranslate"><span class="pre">N</span></code> consecutive
<code class="docutils literal notranslate"><span class="pre">T</span></code> values, either <code class="docutils literal notranslate"><span class="pre">aligned</span></code> (address is a multiple of the vector
size) or possibly unaligned (denoted <code class="docutils literal notranslate"><span class="pre">p</span></code>).</p>
<p>Even unaligned addresses must still be a multiple of <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>,
otherwise <code class="docutils literal notranslate"><span class="pre">StoreU</span></code> may crash on some platforms (e.g. RVV and Armv7).
Note that C++ ensures automatic (stack) and dynamically allocated (via
<code class="docutils literal notranslate"><span class="pre">new</span></code> or <code class="docutils literal notranslate"><span class="pre">malloc</span></code>) variables of type <code class="docutils literal notranslate"><span class="pre">T</span></code> are aligned to
<code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>, hence such addresses are suitable for <code class="docutils literal notranslate"><span class="pre">StoreU</span></code>.
However, casting pointers to <code class="docutils literal notranslate"><span class="pre">char*</span></code> and adding arbitrary offsets (not
a multiple of <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>) can violate this requirement.</p>
<p><strong>Note</strong>: computations with low arithmetic intensity (FLOP/s per memory
traffic bytes), e.g. dot product, can be <em>1.5 times as fast</em> when the
memory operands are aligned to the vector size. An unaligned access may
require two load ports.</p>
<div class="section" id="load">
<h4>Load<a class="headerlink" href="#load" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>Vec&lt;D&gt; <strong>Load</strong>(D, const T* aligned): returns <code class="docutils literal notranslate"><span class="pre">aligned[i]</span></code>. May
fault if the pointer is not aligned to the vector size (using
aligned_allocator.h is safe). Using this whenever possible improves
codegen on SSSE3/SSE4: unlike <code class="docutils literal notranslate"><span class="pre">LoadU</span></code>, <code class="docutils literal notranslate"><span class="pre">Load</span></code> can be fused into a
memory operand, which reduces register pressure.</p></li>
</ul>
<p>Requires only <em>element-aligned</em> vectors (e.g. from malloc/std::vector,
or aligned memory at indices which are not a multiple of the vector
length):</p>
<ul>
<li><p>Vec&lt;D&gt; <strong>LoadU</strong>(D, const T* p): returns <code class="docutils literal notranslate"><span class="pre">p[i]</span></code>.</p></li>
<li><p>Vec&lt;D&gt; <strong>LoadDup128</strong>(D, const T* p): returns one 128-bit block
loaded from <code class="docutils literal notranslate"><span class="pre">p</span></code> and broadcasted into all 128-bit block[s]. This may
be faster than broadcasting single values, and is more convenient
than preparing constants for the actual vector length. Only available
if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</p></li>
<li><p>Vec&lt;D&gt; <strong>MaskedLoadOr</strong>(V no, M mask, D, const T* p): returns
<code class="docutils literal notranslate"><span class="pre">mask[i]</span> <span class="pre">?</span> <span class="pre">p[i]</span> <span class="pre">:</span> <span class="pre">no[i]</span></code>. May fault even where <code class="docutils literal notranslate"><span class="pre">mask</span></code> is false
<code class="docutils literal notranslate"><span class="pre">#if</span>&#160;&#160;&#160;&#160; <span class="pre">HWY_MEM_OPS_MIGHT_FAULT</span></code>. If <code class="docutils literal notranslate"><span class="pre">p</span></code> is aligned, faults
cannot happen unless the entire vector is inaccessible. Assuming no
faults, this is equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">IfThenElse(mask,</span> <span class="pre">LoadU(D(),</span> <span class="pre">p),</span> <span class="pre">no)</span></code>.</p></li>
<li><p>Vec&lt;D&gt; <strong>MaskedLoad</strong>(M mask, D d, const T* p): equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskedLoadOr(Zero(d),</span> <span class="pre">mask,</span> <span class="pre">d,</span> <span class="pre">p)</span></code>, but potentially slightly more
efficient.</p></li>
<li><p>Vec&lt;D&gt; <strong>LoadN</strong>(D d, const T* p, size_t max_lanes_to_load) :
Loads <code class="docutils literal notranslate"><span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_load)</span></code> lanes from <code class="docutils literal notranslate"><span class="pre">p</span></code> to
the first (lowest-index) lanes of the result vector and zeroes out
the remaining lanes.</p>
<p>LoadN does not fault if all of the elements in
<code class="docutils literal notranslate"><span class="pre">[p,</span> <span class="pre">p</span> <span class="pre">+</span> <span class="pre">max_lanes_to_load)</span></code> are accessible, even if
<code class="docutils literal notranslate"><span class="pre">HWY_MEM_OPS_MIGHT_FAULT</span></code> is 1 or <code class="docutils literal notranslate"><span class="pre">max_lanes_to_load</span> <span class="pre">&lt;</span> <span class="pre">Lanes(d)</span></code>
is true.</p>
</li>
<li><p>Vec&lt;D&gt; <strong>LoadNOr</strong>(V no, D d, const T* p, size_t
max_lanes_to_load) : Loads <code class="docutils literal notranslate"><span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_load)</span></code>
lanes from <code class="docutils literal notranslate"><span class="pre">p</span></code> to the first (lowest-index) lanes of the result
vector and fills the remaining lanes with <code class="docutils literal notranslate"><span class="pre">no</span></code>. Like LoadN, this
does not fault.</p></li>
<li><p>Vec&lt;D&gt; <strong>InsertIntoUpper</strong>(D d, T* p, V v): Loads <code class="docutils literal notranslate"><span class="pre">Lanes(d)/2</span></code></p></li>
</ul>
<blockquote>
<div><p>lanes from <code class="docutils literal notranslate"><span class="pre">p</span></code> into the upper lanes of the result vector and the
lower half of <code class="docutils literal notranslate"><span class="pre">v</span></code> into the lower lanes.</p>
</div></blockquote>
</div>
<div class="section" id="store">
<h4>Store<a class="headerlink" href="#store" title="Permalink to this heading"></a></h4>
<ul>
<li><p>void <strong>Store</strong>(Vec&lt;D&gt; v, D, T* aligned): copies <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> into
<code class="docutils literal notranslate"><span class="pre">aligned[i]</span></code>, which must be aligned to the vector size. Writes
exactly <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">*</span> <span class="pre">sizeof(T)</span></code> bytes.</p></li>
<li><p>void <strong>StoreU</strong>(Vec&lt;D&gt; v, D, T* p): as <code class="docutils literal notranslate"><span class="pre">Store</span></code>, but the
alignment requirement is relaxed to element-aligned (multiple of
<code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>).</p></li>
<li><p>void <strong>BlendedStore</strong>(Vec&lt;D&gt; v, M m, D d, T* p): as <code class="docutils literal notranslate"><span class="pre">StoreU</span></code>,
but only updates <code class="docutils literal notranslate"><span class="pre">p</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is true. May fault even where
<code class="docutils literal notranslate"><span class="pre">mask</span></code> is false <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">HWY_MEM_OPS_MIGHT_FAULT</span></code>. If <code class="docutils literal notranslate"><span class="pre">p</span></code> is
aligned, faults cannot happen unless the entire vector is
inaccessible. Equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">StoreU(IfThenElse(m,</span> <span class="pre">v,</span> <span class="pre">LoadU(d,</span> <span class="pre">p)),</span> <span class="pre">d,</span>&#160;&#160;&#160;&#160; <span class="pre">p)</span></code>. “Blended”
indicates this may not be atomic; other threads must not concurrently
update <code class="docutils literal notranslate"><span class="pre">[p,</span> <span class="pre">p</span> <span class="pre">+</span> <span class="pre">Lanes(d))</span></code> without synchronization.</p></li>
<li><p>void <strong>SafeFillN</strong>(size_t num, T value, D d, T* HWY_RESTRICT to):
Sets <code class="docutils literal notranslate"><span class="pre">to[0,</span> <span class="pre">num)</span></code> to <code class="docutils literal notranslate"><span class="pre">value</span></code>. If <code class="docutils literal notranslate"><span class="pre">num</span></code> exceeds <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>,
the behavior is target-dependent (either filling all, or no more than
one vector). Potentially more efficient than a scalar loop, but will
not fault, unlike <code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code>. No alignment requirement.
Potentially non-atomic, like <code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code>.</p></li>
<li><p>void <strong>SafeCopyN</strong>(size_t num, D d, const T* HWY_RESTRICT from,
T* HWY_RESTRICT to): Copies <code class="docutils literal notranslate"><span class="pre">from[0,</span> <span class="pre">num)</span></code> to <code class="docutils literal notranslate"><span class="pre">to</span></code>. If <code class="docutils literal notranslate"><span class="pre">num</span></code>
exceeds <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>, the behavior is target-dependent (either
copying all, or no more than one vector). Potentially more efficient
than a scalar loop, but will not fault, unlike <code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code>. No
alignment requirement. Potentially non-atomic, like <code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code>.</p></li>
<li><p>void <strong>StoreN</strong>(Vec&lt;D&gt; v, D d, T* HWY_RESTRICT p, size_t
max_lanes_to_store): Stores the first (lowest-index)
<code class="docutils literal notranslate"><span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_store)</span></code> lanes of <code class="docutils literal notranslate"><span class="pre">v</span></code> to p.</p>
<p>StoreN does not modify any memory past
<code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">+</span> <span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_store)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</li>
<li><p>void <strong>TruncateStore</strong>(Vec&lt;D&gt; v, D d, T* HWY_RESTRICT p):
Truncates elements of <code class="docutils literal notranslate"><span class="pre">v</span></code> to type <code class="docutils literal notranslate"><span class="pre">T</span></code> and stores on <code class="docutils literal notranslate"><span class="pre">p</span></code>. It is
similar to performing <code class="docutils literal notranslate"><span class="pre">TruncateTo</span></code> followed by <code class="docutils literal notranslate"><span class="pre">StoreU</span></code>.</p></li>
</ul>
</div>
<div class="section" id="interleaved">
<h4>Interleaved<a class="headerlink" href="#interleaved" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>void <strong>LoadInterleaved2</strong>(D, const T* p, Vec&lt;D&gt;&amp; v0, Vec&lt;D&gt;&amp; v1):
equivalent to <code class="docutils literal notranslate"><span class="pre">LoadU</span></code> into <code class="docutils literal notranslate"><span class="pre">v0,</span> <span class="pre">v1</span></code> followed by shuffling, such
that <code class="docutils literal notranslate"><span class="pre">v0[0]</span> <span class="pre">==</span> <span class="pre">p[0],</span> <span class="pre">v1[0]</span> <span class="pre">==</span> <span class="pre">p[1]</span></code>.</p></li>
<li><p>void <strong>LoadInterleaved3</strong>(D, const T* p, Vec&lt;D&gt;&amp; v0, Vec&lt;D&gt;&amp; v1,
Vec&lt;D&gt;&amp; v2): as above, but for three vectors (e.g. RGB samples).</p></li>
<li><p>void <strong>LoadInterleaved4</strong>(D, const T* p, Vec&lt;D&gt;&amp; v0, Vec&lt;D&gt;&amp; v1,
Vec&lt;D&gt;&amp; v2, Vec&lt;D&gt;&amp; v3): as above, but for four vectors (e.g. RGBA).</p></li>
<li><p>void <strong>StoreInterleaved2</strong>(Vec&lt;D&gt; v0, Vec&lt;D&gt; v1, D, T* p):
equivalent to shuffling <code class="docutils literal notranslate"><span class="pre">v0,</span> <span class="pre">v1</span></code> followed by two <code class="docutils literal notranslate"><span class="pre">StoreU()</span></code>, such
that <code class="docutils literal notranslate"><span class="pre">p[0]</span> <span class="pre">==</span> <span class="pre">v0[0],</span> <span class="pre">p[1]</span> <span class="pre">==</span> <span class="pre">v1[0]</span></code>.</p></li>
<li><p>void <strong>StoreInterleaved3</strong>(Vec&lt;D&gt; v0, Vec&lt;D&gt; v1, Vec&lt;D&gt; v2, D, T*
p): as above, but for three vectors (e.g. RGB samples).</p></li>
<li><p>void <strong>StoreInterleaved4</strong>(Vec&lt;D&gt; v0, Vec&lt;D&gt; v1, Vec&lt;D&gt; v2, Vec&lt;D&gt;
v3, D, T* p): as above, but for four vectors (e.g. RGBA samples).</p></li>
</ul>
</div>
<div class="section" id="scatter-gather">
<h4>Scatter/Gather<a class="headerlink" href="#scatter-gather" title="Permalink to this heading"></a></h4>
<p><strong>Note</strong>: Offsets/indices are of type <code class="docutils literal notranslate"><span class="pre">VI</span> <span class="pre">=</span> <span class="pre">Vec&lt;RebindToSigned&lt;D&gt;&gt;</span></code>
and need not be unique. The results are implementation-defined for
negative offsets, because behavior differs between x86 and RVV (signed
vs. unsigned).</p>
<p><strong>Note</strong>: Where possible, applications should
<code class="docutils literal notranslate"><span class="pre">Load/Store/TableLookup*</span></code> entire vectors, which is much faster than
<code class="docutils literal notranslate"><span class="pre">Scatter/Gather</span></code>. Otherwise, code of the form
<code class="docutils literal notranslate"><span class="pre">dst[tbl[i]]</span> <span class="pre">=</span> <span class="pre">F(src[i])</span></code> should when possible be transformed to
<code class="docutils literal notranslate"><span class="pre">dst[i]</span> <span class="pre">=</span> <span class="pre">F(src[tbl[i]])</span></code> because <code class="docutils literal notranslate"><span class="pre">Scatter</span></code> may be more expensive
than <code class="docutils literal notranslate"><span class="pre">Gather</span></code>.</p>
<p><strong>Note</strong>: We provide <code class="docutils literal notranslate"><span class="pre">*Offset</span></code> functions for the convenience of users
that have actual byte offsets. However, the preferred interface is
<code class="docutils literal notranslate"><span class="pre">*Index</span></code>, which takes indices. To reduce the number of ops, we do not
intend to add <code class="docutils literal notranslate"><span class="pre">Masked*</span></code> ops for offsets. If you have offsets, you can
convert them to indices via <code class="docutils literal notranslate"><span class="pre">ShiftRight</span></code>.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">void <strong>ScatterOffset</strong>(Vec&lt;D&gt; v, D, T* base, VI offsets): stores
<code class="docutils literal notranslate"><span class="pre">v[i]</span></code> to the base address plus <em>byte</em> <code class="docutils literal notranslate"><span class="pre">offsets[i]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">void <strong>ScatterIndex</strong>(Vec&lt;D&gt; v, D, T* base, VI indices): stores
<code class="docutils literal notranslate"><span class="pre">v[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">void <strong>ScatterIndexN</strong>(Vec&lt;D&gt; v, D, T* base, VI indices, size_t
max_lanes_to_store): Stores
<code class="docutils literal notranslate"><span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_store)</span></code> lanes <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> to
<code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">void <strong>MaskedScatterIndex</strong>(Vec&lt;D&gt; v, M m, D, T* base, VI
indices): stores <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code> if <code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is
true. Does not fault for lanes whose <code class="docutils literal notranslate"><span class="pre">mask</span></code> is false.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>GatherOffset</strong>(D, const T* base, VI offsets): returns
elements of base selected by <em>byte</em> <code class="docutils literal notranslate"><span class="pre">offsets[i]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>GatherIndex</strong>(D, const T* base, VI indices): returns
vector of <code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>GatherIndexN</strong>(D, const T* base, VI indices, size_t
max_lanes_to_load): Loads <code class="docutils literal notranslate"><span class="pre">HWY_MIN(Lanes(d),</span> <span class="pre">max_lanes_to_load)</span></code>
lanes of <code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code> to the first (lowest-index) lanes of
the result vector and zeroes out the remaining lanes.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>MaskedGatherIndexOr</strong>(V no, M mask, D d, const T* base,
VI indices): returns vector of <code class="docutils literal notranslate"><span class="pre">base[indices[i]]</span></code> where
<code class="docutils literal notranslate"><span class="pre">mask[i]</span></code> is true, otherwise <code class="docutils literal notranslate"><span class="pre">no[i]</span></code>. Does not fault for lanes
whose <code class="docutils literal notranslate"><span class="pre">mask</span></code> is false. This is equivalent to, and potentially
more efficient than,
<code class="docutils literal notranslate"><span class="pre">IfThenElseZero(mask,</span> <span class="pre">GatherIndex(d,</span> <span class="pre">base,</span> <span class="pre">indices))</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32,64}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>MaskedGatherIndex</strong>(M mask, D d, const T* base, VI
indices): equivalent to
<code class="docutils literal notranslate"><span class="pre">MaskedGatherIndexOr(Zero(d),</span> <span class="pre">mask,</span> <span class="pre">d,</span> <span class="pre">base,</span>&#160;&#160;&#160;&#160; <span class="pre">indices)</span></code>. Use
this when the desired default value is zero; it may be more
efficient on some targets, and on others require generating a zero
constant.</div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="cache-control">
<h3>Cache control<a class="headerlink" href="#cache-control" title="Permalink to this heading"></a></h3>
<p>All functions except <code class="docutils literal notranslate"><span class="pre">Stream</span></code> are defined in cache_control.h.</p>
<ul class="simple">
<li><p>void <strong>Stream</strong>(Vec&lt;D&gt; a, D d, const T* aligned): copies <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>
into <code class="docutils literal notranslate"><span class="pre">aligned[i]</span></code> with non-temporal hint if available (useful for
write-only data; avoids cache pollution). May be implemented using a
CPU-internal buffer. To avoid partial flushes and unpredictable
interactions with atomics (for example, see Intel SDM Vol 4, Sec.
8.1.2.2), call this consecutively for an entire cache line (typically
64 bytes, aligned to its size). Each call may write a multiple of
<code class="docutils literal notranslate"><span class="pre">HWY_STREAM_MULTIPLE</span></code> bytes, which can exceed
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">*</span> <span class="pre">sizeof(T)</span></code>. The new contents of <code class="docutils literal notranslate"><span class="pre">aligned</span></code> may not be
visible until <code class="docutils literal notranslate"><span class="pre">FlushStream</span></code> is called.</p></li>
<li><p>void <strong>FlushStream</strong>(): ensures values written by previous
<code class="docutils literal notranslate"><span class="pre">Stream</span></code> calls are visible on the current core. This is NOT
sufficient for synchronizing across cores; when <code class="docutils literal notranslate"><span class="pre">Stream</span></code> outputs
are to be consumed by other core(s), the producer must publish
availability (e.g. via mutex or atomic_flag) after <code class="docutils literal notranslate"><span class="pre">FlushStream</span></code>.</p></li>
<li><p>void <strong>FlushCacheline</strong>(const void* p): invalidates and flushes
the cache line containing “p”, if possible.</p></li>
<li><p>void <strong>Prefetch</strong>(const T* p): optionally begins loading the cache
line containing “p” to reduce latency of subsequent actual loads.</p></li>
<li><p>void <strong>Pause</strong>(): when called inside a spin-loop, may reduce power
consumption.</p></li>
</ul>
</div>
<div class="section" id="type-conversion">
<h3>Type conversion<a class="headerlink" href="#type-conversion" title="Permalink to this heading"></a></h3>
<ul>
<li><p>Vec&lt;D&gt; <strong>BitCast</strong>(D, V): returns the bits of <code class="docutils literal notranslate"><span class="pre">V</span></code> reinterpreted
as type <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code>.</p></li>
<li><p>Vec&lt;D&gt; <strong>ResizeBitCast</strong>(D, V): resizes <code class="docutils literal notranslate"><span class="pre">V</span></code> to a vector of
<code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;D&gt;)</span></code> bytes, and then returns the bits
of the resized vector reinterpreted as type <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Vec&lt;D&gt;</span></code> is a larger vector than <code class="docutils literal notranslate"><span class="pre">V</span></code>, then the contents of any
bytes past the first <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromV&lt;V&gt;)</span></code> bytes
of the result vector is unspecified.</p>
</li>
<li><p>Vec&lt;DTo&gt; <strong>ZeroExtendResizeBitCast</strong>(DTo, DFrom, V): resizes <code class="docutils literal notranslate"><span class="pre">V</span></code>,
which is a vector of type <code class="docutils literal notranslate"><span class="pre">Vec&lt;DFrom&gt;</span></code>, to a vector of
<code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;D&gt;)</span></code> bytes, and then returns the bits
of the resized vector reinterpreted as type <code class="docutils literal notranslate"><span class="pre">Vec&lt;DTo&gt;</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(DTo())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;DTo&gt;)</span></code> is greater than
<code class="docutils literal notranslate"><span class="pre">Lanes(DFrom())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;DFrom&gt;)</span></code>, then any bytes past the
first <code class="docutils literal notranslate"><span class="pre">Lanes(DFrom())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromD&lt;DFrom&gt;)</span></code> bytes of the result
vector are zeroed out.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">V8</span></code>: (<code class="docutils literal notranslate"><span class="pre">u32,u8</span></code>)</div>
<div class="line">V8 <strong>U8FromU32</strong>(V): special-case <code class="docutils literal notranslate"><span class="pre">u32</span></code> to <code class="docutils literal notranslate"><span class="pre">u8</span></code> conversion
when all lanes of <code class="docutils literal notranslate"><span class="pre">V</span></code> are already clamped to <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">256)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>ConvertTo</strong>(D, V): converts a signed/unsigned integer
value to same-sized floating point.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>ConvertTo</strong>(D, V): rounds floating point towards zero
and converts the value to same-sized signed/unsigned integer.
Returns the closest representable value if the input exceeds the
destination range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{f}</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>ConvertInRangeTo</strong>(D, V): rounds floating point towards
zero and converts the value to same-sized signed/unsigned integer.
Returns an implementation-defined value if the input exceeds the
destination range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code>; <code class="docutils literal notranslate"><span class="pre">Ret</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToSigned&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">Ret <strong>NearestInt</strong>(V a): returns the integer nearest to <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>;
results are undefined for NaN.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code>; <code class="docutils literal notranslate"><span class="pre">Ret</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToSigned&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">Ret <strong>CeilInt</strong>(V a): equivalent to
<code class="docutils literal notranslate"><span class="pre">ConvertTo(RebindToSigned&lt;DFromV&lt;V&gt;&gt;(),</span> <span class="pre">Ceil(a))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">CeilInt(a)</span></code> is more efficient on some targets, including SSE2,
SSSE3, and AArch64 NEON.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f</span></code>; <code class="docutils literal notranslate"><span class="pre">Ret</span></code>: <code class="docutils literal notranslate"><span class="pre">Vec&lt;RebindToSigned&lt;DFromV&lt;V&gt;&gt;&gt;</span></code></div>
<div class="line">Ret <strong>FloorInt</strong>(V a): equivalent to
<code class="docutils literal notranslate"><span class="pre">ConvertTo(RebindToSigned&lt;DFromV&lt;V&gt;&gt;(),</span> <span class="pre">Floor(a))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">FloorInt(a)</span></code> is more efficient on some targets, including SSE2,
SSSE3, and AArch64 NEON.</div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">i32</span></code>, <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">f64</span></code> Vec&lt;D&gt; <strong>DemoteToNearestInt</strong>(D d, V
v): converts <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>, rounding to nearest (with
ties to even).</p>
<p><code class="docutils literal notranslate"><span class="pre">DemoteToNearestInt(d,</span> <span class="pre">v)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">DemoteTo(d,</span> <span class="pre">Round(v))</span></code>, but <code class="docutils literal notranslate"><span class="pre">DemoteToNearestInt(d,</span> <span class="pre">v)</span></code> is more
efficient on some targets, including x86 and RVV.</p>
</li>
<li><p>Vec&lt;D&gt; <strong>MaskedConvertTo</strong>(M m, D d, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code>
converted to <code class="docutils literal notranslate"><span class="pre">D</span></code> where m is active and returns zero otherwise.</p></li>
</ul>
<div class="section" id="single-vector-demotion">
<h4>Single vector demotion<a class="headerlink" href="#single-vector-demotion" title="Permalink to this heading"></a></h4>
<p>These functions demote a full vector (or parts thereof) into a vector of
half the size. Use <code class="docutils literal notranslate"><span class="pre">Rebind&lt;MakeNarrow&lt;T&gt;,</span> <span class="pre">D&gt;</span></code> or
<code class="docutils literal notranslate"><span class="pre">Half&lt;RepartitionToNarrow&lt;D&gt;&gt;</span></code> to obtain the <code class="docutils literal notranslate"><span class="pre">D</span></code> that describes the
return type.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">u64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,u8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u16,u8</span></code>)</div>
<div class="line">Vec&lt;D&gt; <strong>TruncateTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> truncated to the
smaller type indicated by <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">TFromD&lt;D&gt;</span></code>, with the same result
as if the more-significant input bits that do not fit in <code class="docutils literal notranslate"><span class="pre">T</span></code> had
been zero. Example:
<code class="docutils literal notranslate"><span class="pre">ScalableTag&lt;uint32_t&gt;</span> <span class="pre">du32;</span> <span class="pre">Rebind&lt;uint8_t&gt;</span> <span class="pre">du8;</span> <span class="pre">TruncateTo(du8,</span>&#160;&#160;&#160;&#160; <span class="pre">Set(du32,</span> <span class="pre">0xF08F))</span></code>
is the same as <code class="docutils literal notranslate"><span class="pre">Set(du8,</span> <span class="pre">0x8F)</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">i16,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i32,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,i8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">i32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,i32</span></code>), (<code class="docutils literal notranslate"><span class="pre">u16,i8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u32,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,i16</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u64,i32</span></code>), (<code class="docutils literal notranslate"><span class="pre">i16,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i32,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,u8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">i32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">u16,u8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u32,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,u16</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">f64,f32</span></code>)</div>
<div class="line">Vec&lt;D&gt; <strong>DemoteTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> after packing with
signed/unsigned saturation to <code class="docutils literal notranslate"><span class="pre">MakeNarrow&lt;T&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">f64,{u,i}32</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>DemoteTo</strong>(D, V v): rounds floating point towards zero
and converts the value to 32-bit integers. Returns the closest
representable value if the input exceeds the destination range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">f64,{u,i}32</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>DemoteInRangeTo</strong>(D, V v): rounds floating point towards
zero and converts the value to 32-bit integers. Returns an
implementation-defined value if the input exceeds the destination
range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}64,f32</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>DemoteTo</strong>(D, V v): converts 64-bit integer to
<code class="docutils literal notranslate"><span class="pre">float</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">f32,f16</span></code>), (<code class="docutils literal notranslate"><span class="pre">f64,f16</span></code>), (<code class="docutils literal notranslate"><span class="pre">f32,bf16</span></code>)</div>
<div class="line">Vec&lt;D&gt; <strong>DemoteTo</strong>(D, V v): narrows float to half (for bf16, it
is unspecified whether this truncates or rounds).</div>
</div>
</li>
</ul>
</div>
<div class="section" id="single-vector-promotion">
<h4>Single vector promotion<a class="headerlink" href="#single-vector-promotion" title="Permalink to this heading"></a></h4>
<p>These functions promote a half vector to a full vector. To obtain
halves, use <code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> or <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>, or load them using a
half-sized <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<ul>
<li><div class="line-block">
<div class="line">Unsigned <code class="docutils literal notranslate"><span class="pre">V</span></code> to wider signed/unsigned <code class="docutils literal notranslate"><span class="pre">D</span></code>; signed to wider
signed, <code class="docutils literal notranslate"><span class="pre">f16</span></code> to <code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">f16</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code>, <code class="docutils literal notranslate"><span class="pre">bf16</span></code> to
<code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteTo</strong>(D, V part): returns <code class="docutils literal notranslate"><span class="pre">part[i]</span></code> zero- or
sign-extended to the integer type <code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code>, or widened to
the floating-point type <code class="docutils literal notranslate"><span class="pre">MakeFloat&lt;MakeWide&lt;T&gt;&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">{u,i}32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteTo</strong>(D, V part): returns <code class="docutils literal notranslate"><span class="pre">part[i]</span></code> widened to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteTo</strong>(D, V part): rounds <code class="docutils literal notranslate"><span class="pre">part[i]</span></code> towards zero
and converts the rounded value to a 64-bit signed or unsigned
integer. Returns the representable value if the input exceeds the
destination range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteInRangeTo</strong>(D, V part): rounds <code class="docutils literal notranslate"><span class="pre">part[i]</span></code>
towards zero and converts the rounded value to a 64-bit signed or
unsigned integer. Returns an implementation-defined value if the
input exceeds the destination range.</div>
</div>
</li>
</ul>
<p>The following may be more convenient or efficient than also calling
<code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> / <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line">Unsigned <code class="docutils literal notranslate"><span class="pre">V</span></code> to wider signed/unsigned <code class="docutils literal notranslate"><span class="pre">D</span></code>; signed to wider
signed, <code class="docutils literal notranslate"><span class="pre">f16</span></code> to <code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">bf16</span></code> to <code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteLowerTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> widened to
<code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code>, for i in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has
twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">{u,i}32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteLowerTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> widened to
<code class="docutils literal notranslate"><span class="pre">double</span></code>, for i in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice
as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteLowerTo</strong>(D, V v): rounds <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> towards zero
and converts the rounded value to a 64-bit signed or unsigned
integer, for i in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as
many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteInRangeLowerTo</strong>(D, V v): rounds <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> towards
zero and converts the rounded value to a 64-bit signed or unsigned
integer, for i in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as
many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. Returns an
implementation-defined value if the input exceeds the destination
range.</div>
</div>
</li>
<li><div class="line-block">
<div class="line">Unsigned <code class="docutils literal notranslate"><span class="pre">V</span></code> to wider signed/unsigned <code class="docutils literal notranslate"><span class="pre">D</span></code>; signed to wider
signed, <code class="docutils literal notranslate"><span class="pre">f16</span></code> to <code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">bf16</span></code> to <code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteUpperTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> widened to
<code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code>, for i in <code class="docutils literal notranslate"><span class="pre">[Lanes(D()),</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(D()))</span></code>. Note
that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value.
Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">{u,i}32</span></code> to <code class="docutils literal notranslate"><span class="pre">f64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteUpperTo</strong>(D, V v): returns <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> widened to
<code class="docutils literal notranslate"><span class="pre">double</span></code>, for i in <code class="docutils literal notranslate"><span class="pre">[Lanes(D()),</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(D()))</span></code>. Note that
<code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. Only
available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteUpperTo</strong>(D, V v): rounds <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> towards zero
and converts the rounded value to a 64-bit signed or unsigned
integer, for i in <code class="docutils literal notranslate"><span class="pre">[Lanes(D()),</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code>
has twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. Only
available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">f32</span></code> to <code class="docutils literal notranslate"><span class="pre">i64</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteInRangeUpperTo</strong>(D, V v): rounds <code class="docutils literal notranslate"><span class="pre">v[i]</span></code> towards
zero and converts the rounded value to a 64-bit signed or unsigned
integer, for i in <code class="docutils literal notranslate"><span class="pre">[Lanes(D()),</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(D()))</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code>
has twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. Returns an
implementation-defined value if the input exceeds the destination
range. Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
</ul>
<p>The following may be more convenient or efficient than also calling
<code class="docutils literal notranslate"><span class="pre">ConcatEven</span></code> or <code class="docutils literal notranslate"><span class="pre">ConcatOdd</span></code> followed by <code class="docutils literal notranslate"><span class="pre">PromoteLowerTo</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>:<code class="docutils literal notranslate"><span class="pre">{u,i}{8,16,32},f{16,32},bf16</span></code>,
<code class="docutils literal notranslate"><span class="pre">D</span></code>:<code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteEvenTo</strong>(D, V v): promotes the even lanes of
<code class="docutils literal notranslate"><span class="pre">v</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes as
<code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. <code class="docutils literal notranslate"><span class="pre">PromoteEvenTo(d,</span> <span class="pre">v)</span></code> is equivalent
to, but potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">PromoteLowerTo(d,</span> <span class="pre">ConcatEven(Repartition&lt;TFromV&lt;V&gt;,</span> <span class="pre">D&gt;(),</span> <span class="pre">v,</span>&#160;&#160;&#160;&#160; <span class="pre">v))</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>:<code class="docutils literal notranslate"><span class="pre">{u,i}{8,16,32},f{16,32},bf16</span></code>,
<code class="docutils literal notranslate"><span class="pre">D</span></code>:<code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteOddTo</strong>(D, V v): promotes the odd lanes of <code class="docutils literal notranslate"><span class="pre">v</span></code>
to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes as <code class="docutils literal notranslate"><span class="pre">D</span></code>
and the return value. <code class="docutils literal notranslate"><span class="pre">PromoteOddTo(d,</span> <span class="pre">v)</span></code> is equivalent to, but
potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">PromoteLowerTo(d,</span> <span class="pre">ConcatOdd(Repartition&lt;TFromV&lt;V&gt;,</span> <span class="pre">D&gt;(),</span> <span class="pre">v,</span>&#160;&#160;&#160;&#160; <span class="pre">v))</span></code>.
Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>:<code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>:<code class="docutils literal notranslate"><span class="pre">{u,i}64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteInRangeEvenTo</strong>(D, V v): promotes the even lanes
of <code class="docutils literal notranslate"><span class="pre">v</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes
as <code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. <code class="docutils literal notranslate"><span class="pre">PromoteInRangeEvenTo(d,</span> <span class="pre">v)</span></code> is
equivalent to, but potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">PromoteInRangeLowerTo(d,</span> <span class="pre">ConcatEven(</span>&#160;&#160;&#160;&#160; <span class="pre">Repartition&lt;TFromV&lt;V&gt;,</span> <span class="pre">D&gt;(),</span> <span class="pre">v,</span> <span class="pre">v))</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>:<code class="docutils literal notranslate"><span class="pre">f32</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code>:<code class="docutils literal notranslate"><span class="pre">{u,i}64</span></code></div>
<div class="line">Vec&lt;D&gt; <strong>PromoteInRangeOddTo</strong>(D, V v): promotes the odd lanes of
<code class="docutils literal notranslate"><span class="pre">v</span></code> to <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">V</span></code> has twice as many lanes as
<code class="docutils literal notranslate"><span class="pre">D</span></code> and the return value. <code class="docutils literal notranslate"><span class="pre">PromoteInRangeOddTo(d,</span> <span class="pre">v)</span></code> is
equivalent to, but potentially more efficient than
<code class="docutils literal notranslate"><span class="pre">PromoteInRangeLowerTo(d,</span> <span class="pre">ConcatOdd(</span>&#160;&#160;&#160;&#160; <span class="pre">Repartition&lt;TFromV&lt;V&gt;,</span> <span class="pre">D&gt;(),</span> <span class="pre">v,</span> <span class="pre">v))</span></code>.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="two-vector-demotion">
<h4>Two-vector demotion<a class="headerlink" href="#two-vector-demotion" title="Permalink to this heading"></a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">i16,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,i32</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u16,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,i32</span></code>), (<code class="docutils literal notranslate"><span class="pre">i16,u8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">i32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">u16,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,u16</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">f32,bf16</span></code>)</div>
<div class="line">Vec&lt;D&gt; <strong>ReorderDemote2To</strong>(D, V a, V b): as above, but converts
two inputs, <code class="docutils literal notranslate"><span class="pre">D</span></code> and the output have twice as many lanes as <code class="docutils literal notranslate"><span class="pre">V</span></code>,
and the output order is some permutation of the inputs. Only
available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">i16,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">i32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,i32</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u16,i8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,i16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,i32</span></code>), (<code class="docutils literal notranslate"><span class="pre">i16,u8</span></code>),
(<code class="docutils literal notranslate"><span class="pre">i32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">i64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">u16,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,u16</span></code>),
(<code class="docutils literal notranslate"><span class="pre">u64,u32</span></code>), (<code class="docutils literal notranslate"><span class="pre">f32,bf16</span></code>)</div>
<div class="line">Vec&lt;D&gt; <strong>OrderedDemote2To</strong>(D d, V a, V b): as above, but
converts two inputs, <code class="docutils literal notranslate"><span class="pre">D</span></code> and the output have twice as many lanes
as <code class="docutils literal notranslate"><span class="pre">V</span></code>, and the output order is the result of demoting the
elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the lower half of the result followed by the
result of demoting the elements of <code class="docutils literal notranslate"><span class="pre">b</span></code> in the upper half of the
result. <code class="docutils literal notranslate"><span class="pre">OrderedDemote2To(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Combine(d,</span> <span class="pre">DemoteTo(Half&lt;D&gt;(),</span> <span class="pre">b),</span> <span class="pre">DemoteTo(Half&lt;D&gt;(),</span> <span class="pre">a))</span></code>, but
typically more efficient. Note that integer inputs are saturated to
the destination range as with <code class="docutils literal notranslate"><span class="pre">DemoteTo</span></code>. Only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>,<code class="docutils literal notranslate"><span class="pre">D</span></code>: (<code class="docutils literal notranslate"><span class="pre">u16,u8</span></code>), (<code class="docutils literal notranslate"><span class="pre">u32,u16</span></code>), (<code class="docutils literal notranslate"><span class="pre">u64,u32</span></code>),</div>
<div class="line">Vec&lt;D&gt; <strong>OrderedTruncate2To</strong>(D d, V a, V b): as above, but
converts two inputs, <code class="docutils literal notranslate"><span class="pre">D</span></code> and the output have twice as many lanes
as <code class="docutils literal notranslate"><span class="pre">V</span></code>, and the output order is the result of truncating the
elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the lower half of the result followed by the
result of truncating the elements of <code class="docutils literal notranslate"><span class="pre">b</span></code> in the upper half of the
result. <code class="docutils literal notranslate"><span class="pre">OrderedTruncate2To(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Combine(d,</span> <span class="pre">TruncateTo(Half&lt;D&gt;(),</span> <span class="pre">b),</span> <span class="pre">TruncateTo(Half&lt;D&gt;(),</span>&#160;&#160;&#160;&#160; <span class="pre">a))</span></code>,
but <code class="docutils literal notranslate"><span class="pre">OrderedTruncate2To(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is typically more efficient
than
<code class="docutils literal notranslate"><span class="pre">Combine(d,</span> <span class="pre">TruncateTo(Half&lt;D&gt;(),</span> <span class="pre">b),</span> <span class="pre">TruncateTo(Half&lt;D&gt;(),</span> <span class="pre">a))</span></code>.
Only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="combine">
<h3>Combine<a class="headerlink" href="#combine" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>V2 <strong>LowerHalf</strong>([D, ] V): returns the lower half of the vector
<code class="docutils literal notranslate"><span class="pre">V</span></code>. The optional <code class="docutils literal notranslate"><span class="pre">D</span></code> (provided for consistency with
<code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>) is <code class="docutils literal notranslate"><span class="pre">Half&lt;DFromV&lt;V&gt;&gt;</span></code>.</p></li>
</ul>
<p>All other ops in this section are only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul class="simple">
<li><p>V2 <strong>UpperHalf</strong>(D, V): returns upper half of the vector <code class="docutils literal notranslate"><span class="pre">V</span></code>,
where <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">Half&lt;DFromV&lt;V&gt;&gt;</span></code>.</p></li>
<li><p>V <strong>ZeroExtendVector</strong>(D, V2): returns vector whose <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>
is zero and whose <code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> is the argument; <code class="docutils literal notranslate"><span class="pre">D</span></code> is
<code class="docutils literal notranslate"><span class="pre">Twice&lt;DFromV&lt;V2&gt;&gt;</span></code>.</p></li>
<li><p>V <strong>Combine</strong>(D, V2, V2): returns vector whose <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code> is the
first argument and whose <code class="docutils literal notranslate"><span class="pre">LowerHalf</span></code> is the second argument; <code class="docutils literal notranslate"><span class="pre">D</span></code>
is <code class="docutils literal notranslate"><span class="pre">Twice&lt;DFromV&lt;V2&gt;&gt;</span></code>.</p></li>
</ul>
<p><strong>Note</strong>: the following operations cross block boundaries, which is
typically more expensive on AVX2/AVX-512 than per-block operations.</p>
<ul class="simple">
<li><p>V <strong>ConcatLowerLower</strong>(D, V hi, V lo): returns the concatenation of
the lower halves of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and <code class="docutils literal notranslate"><span class="pre">lo</span></code> without splitting into blocks.
<code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>ConcatUpperUpper</strong>(D, V hi, V lo): returns the concatenation of
the upper halves of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and <code class="docutils literal notranslate"><span class="pre">lo</span></code> without splitting into blocks.
<code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>ConcatLowerUpper</strong>(D, V hi, V lo): returns the inner half of
the concatenation of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and <code class="docutils literal notranslate"><span class="pre">lo</span></code> without splitting into blocks.
Useful for swapping the two blocks in 256-bit vectors. <code class="docutils literal notranslate"><span class="pre">D</span></code> is
<code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>ConcatUpperLower</strong>(D, V hi, V lo): returns the outer quarters
of the concatenation of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and <code class="docutils literal notranslate"><span class="pre">lo</span></code> without splitting into
blocks. Unlike the other variants, this does not incur a
block-crossing penalty on AVX2/3. <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>ConcatOdd</strong>(D, V hi, V lo): returns the concatenation of the
odd lanes of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and the odd lanes of <code class="docutils literal notranslate"><span class="pre">lo</span></code>.</p></li>
<li><p>V <strong>ConcatEven</strong>(D, V hi, V lo): returns the concatenation of the
even lanes of <code class="docutils literal notranslate"><span class="pre">hi</span></code> and the even lanes of <code class="docutils literal notranslate"><span class="pre">lo</span></code>.</p></li>
<li><p>V <strong>InterleaveWholeLower</strong>([D, ] V a, V b): returns alternating
lanes from the lower halves of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">a[0]</span></code> in the
least-significant lane). The optional <code class="docutils literal notranslate"><span class="pre">D</span></code> (provided for consistency
with <code class="docutils literal notranslate"><span class="pre">InterleaveWholeUpper</span></code>) is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>InterleaveWholeUpper</strong>(D, V a, V b): returns alternating lanes
from the upper halves of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">a[N/2]</span></code> in the
least-significant lane). <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
</ul>
</div>
<div class="section" id="blockwise">
<h3>Blockwise<a class="headerlink" href="#blockwise" title="Permalink to this heading"></a></h3>
<p><strong>Note</strong>: if vectors are larger than 128 bits, the following operations
split their operands into independently processed 128-bit <em>blocks</em>.</p>
<ul class="simple">
<li><p>V <strong>Broadcast</strong>&lt;int i&gt;(V): returns individual <em>blocks</em>, each with
lanes set to <code class="docutils literal notranslate"><span class="pre">input_block[i]</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">16/sizeof(T))</span></code>.</p></li>
</ul>
<p>All other ops in this section are only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">VI <strong>TableLookupBytes</strong>(V bytes, VI indices): returns
<code class="docutils literal notranslate"><span class="pre">bytes[indices[i]]</span></code>. Uses byte lanes regardless of the actual
vector types. Results are implementation-defined if
<code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> or
<code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&gt;=</span>&#160;&#160;&#160;&#160; <span class="pre">HWY_MIN(Lanes(DFromV&lt;V&gt;()),</span> <span class="pre">16)</span></code>. <code class="docutils literal notranslate"><span class="pre">VI</span></code> are
integers, possibly of a different type than those in <code class="docutils literal notranslate"><span class="pre">V</span></code>. The
number of lanes in <code class="docutils literal notranslate"><span class="pre">V</span></code> and <code class="docutils literal notranslate"><span class="pre">VI</span></code> may differ, e.g. a full-length
table vector loaded via <code class="docutils literal notranslate"><span class="pre">LoadDup128</span></code>, plus partial vector <code class="docutils literal notranslate"><span class="pre">VI</span></code>
of 4-bit indices.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">VI <strong>TableLookupBytesOr0</strong>(V bytes, VI indices): returns
<code class="docutils literal notranslate"><span class="pre">bytes[indices[i]]</span></code>, or 0 if <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&amp;</span> <span class="pre">0x80</span></code>. Uses byte
lanes regardless of the actual vector types. Results are
implementation-defined for <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> or in
<code class="docutils literal notranslate"><span class="pre">[HWY_MIN(Lanes(DFromV&lt;V&gt;()),</span> <span class="pre">16),</span> <span class="pre">0x80)</span></code>. The zeroing behavior
has zero cost on x86 and Arm. For vectors of &gt;= 256 bytes (can
happen on SVE and RVV), this will set all lanes after the first 128
to 0. <code class="docutils literal notranslate"><span class="pre">VI</span></code> are integers, possibly of a different type than those
in <code class="docutils literal notranslate"><span class="pre">V</span></code>. The number of lanes in <code class="docutils literal notranslate"><span class="pre">V</span></code> and <code class="docutils literal notranslate"><span class="pre">VI</span></code> may differ.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}64</span></code>, <code class="docutils literal notranslate"><span class="pre">VI</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}8</span></code></div>
<div class="line">V <strong>BitShuffle</strong>(V vals, VI indices): returns a vector with
<code class="docutils literal notranslate"><span class="pre">(vals[i]</span> <span class="pre">&gt;&gt;</span> <span class="pre">indices[i*8+j])</span> <span class="pre">&amp;</span> <span class="pre">1</span></code> in bit <code class="docutils literal notranslate"><span class="pre">j</span></code> of <code class="docutils literal notranslate"><span class="pre">r[i]</span></code> for
each <code class="docutils literal notranslate"><span class="pre">j</span></code> between 0 and 7.</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BitShuffle(vals,</span> <span class="pre">indices)</span></code> zeroes out the upper 56 bits of
<code class="docutils literal notranslate"><span class="pre">r[i]</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">indices[i*8+j]</span></code> is less than 0 or greater than 63, bit <code class="docutils literal notranslate"><span class="pre">j</span></code> of
<code class="docutils literal notranslate"><span class="pre">r[i]</span></code> is implementation-defined.</p>
<p><code class="docutils literal notranslate"><span class="pre">VI</span></code> must be either <code class="docutils literal notranslate"><span class="pre">Vec&lt;Repartition&lt;int8_t,</span> <span class="pre">DFromV&lt;V&gt;&gt;&gt;</span></code> or
<code class="docutils literal notranslate"><span class="pre">Vec&lt;Repartition&lt;uint8_t,</span> <span class="pre">DFromV&lt;V&gt;&gt;&gt;</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">BitShuffle(v,</span> <span class="pre">indices)</span></code> is equivalent to the following loop (where
<code class="docutils literal notranslate"><span class="pre">N</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint64_t</span> <span class="n">shuf_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">shuf_result</span> <span class="o">|=</span> <span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shuf_result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>V <strong>PairwiseAdd128</strong>(D d, V a, V b): Add consecutive pairs of
elements in a and b, and pack results in 128 bit blocks, such that
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">a[i+1]</span></code> for 64 bits, followed by <code class="docutils literal notranslate"><span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">b[i+1]</span></code>
for next 64 bits and repeated.</p></li>
<li><p>V <strong>PairwiseSub128</strong>(D d, V a, V b): Subtract consecutive pairs of
elements in a and b, and pack results in 128 bit blocks, such that
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">+</span> <span class="pre">a[i+1]</span></code> for 64 bits, followed by <code class="docutils literal notranslate"><span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">b[i+1]</span></code>
for next 64 bits and repeated.</p></li>
</ul>
<div class="section" id="interleave">
<h4>Interleave<a class="headerlink" href="#interleave" title="Permalink to this heading"></a></h4>
<p>Ops in this section are only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><p>V <strong>InterleaveLower</strong>([D, ] V a, V b): returns <em>blocks</em> with
alternating lanes from the lower halves of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">a[0]</span></code>
in the least-significant lane). The optional <code class="docutils literal notranslate"><span class="pre">D</span></code> (provided for
consistency with <code class="docutils literal notranslate"><span class="pre">InterleaveUpper</span></code>) is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>InterleaveUpper</strong>(D, V a, V b): returns <em>blocks</em> with
alternating lanes from the upper halves of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>
(<code class="docutils literal notranslate"><span class="pre">a[N/2]</span></code> in the least-significant lane). <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><p>V <strong>InterleaveEven</strong>([D, ] V a, V b): returns alternating lanes
from the even lanes of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">a[0]</span></code> in the
least-significant lane, followed by <code class="docutils literal notranslate"><span class="pre">b[0]</span></code>, followed by <code class="docutils literal notranslate"><span class="pre">a[2]</span></code>,
followed by <code class="docutils literal notranslate"><span class="pre">b[2]</span></code>, and so on). The optional <code class="docutils literal notranslate"><span class="pre">D</span></code> (provided for
consistency with <code class="docutils literal notranslate"><span class="pre">InterleaveOdd</span></code>) is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>. Note that no
lanes move across block boundaries.</p>
<p><code class="docutils literal notranslate"><span class="pre">InterleaveEven(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">InterleaveEven(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> are both
equivalent to <code class="docutils literal notranslate"><span class="pre">OddEven(DupEven(b),</span> <span class="pre">a)</span></code>, but
<code class="docutils literal notranslate"><span class="pre">InterleaveEven(a,</span> <span class="pre">b)</span></code> is usually more efficient than
<code class="docutils literal notranslate"><span class="pre">OddEven(DupEven(b),</span> <span class="pre">a)</span></code>.</p>
</li>
<li><p>V <strong>InterleaveOdd</strong>(D, V a, V b): returns alternating lanes from
the odd lanes of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">a[1]</span></code> in the least-significant
lane, followed by <code class="docutils literal notranslate"><span class="pre">b[1]</span></code>, followed by <code class="docutils literal notranslate"><span class="pre">a[3]</span></code>, followed by
<code class="docutils literal notranslate"><span class="pre">b[3]</span></code>, and so on). <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>. Note that no lanes move
across block boundaries.</p>
<p><code class="docutils literal notranslate"><span class="pre">InterleaveOdd(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">OddEven(b,</span> <span class="pre">DupOdd(a))</span></code>, but <code class="docutils literal notranslate"><span class="pre">InterleaveOdd(d,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> is usually
more efficient than <code class="docutils literal notranslate"><span class="pre">OddEven(b,</span> <span class="pre">DupOdd(a))</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="zip">
<h4>Zip<a class="headerlink" href="#zip" title="Permalink to this heading"></a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Ret</span></code>: <code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code>; <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16,32}</span></code></div>
<div class="line">Ret <strong>ZipLower</strong>([DW, ] V a, V b): returns the same bits as
<code class="docutils literal notranslate"><span class="pre">InterleaveLower</span></code>, but repartitioned into double-width lanes
(required in order to use this operation with scalars). The
optional <code class="docutils literal notranslate"><span class="pre">DW</span></code> (provided for consistency with <code class="docutils literal notranslate"><span class="pre">ZipUpper</span></code>) is
<code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Ret</span></code>: <code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code>; <code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{8,16,32}</span></code></div>
<div class="line">Ret <strong>ZipUpper</strong>(DW, V a, V b): returns the same bits as
<code class="docutils literal notranslate"><span class="pre">InterleaveUpper</span></code>, but repartitioned into double-width lanes
(required in order to use this operation with scalars). <code class="docutils literal notranslate"><span class="pre">DW</span></code> is
<code class="docutils literal notranslate"><span class="pre">RepartitionToWide&lt;DFromV&lt;V&gt;&gt;</span></code>. Only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span>&#160;&#160;&#160;&#160; <span class="pre">HWY_SCALAR</span></code>.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="shift-within-blocks">
<h4>Shift within blocks<a class="headerlink" href="#shift-within-blocks" title="Permalink to this heading"></a></h4>
<p>Ops in this section are only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftLeftBytes</strong>&lt;int&gt;([D, ] V): returns the result of
shifting independent <em>blocks</em> left by <code class="docutils literal notranslate"><span class="pre">int</span></code> bytes [1, 15]. The
optional <code class="docutils literal notranslate"><span class="pre">D</span></code> (provided for consistency with <code class="docutils literal notranslate"><span class="pre">ShiftRightBytes</span></code>)
is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</div>
</div>
</li>
<li><p>V <strong>ShiftLeftLanes</strong>&lt;int&gt;([D, ] V): returns the result of shifting
independent <em>blocks</em> left by <code class="docutils literal notranslate"><span class="pre">int</span></code> lanes. The optional <code class="docutils literal notranslate"><span class="pre">D</span></code>
(provided for consistency with <code class="docutils literal notranslate"><span class="pre">ShiftRightLanes</span></code>) is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ShiftRightBytes</strong>&lt;int&gt;(D, V): returns the result of shifting
independent <em>blocks</em> right by <code class="docutils literal notranslate"><span class="pre">int</span></code> bytes [1, 15], shifting in
zeros even for partial vectors. <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</div>
</div>
</li>
<li><p>V <strong>ShiftRightLanes</strong>&lt;int&gt;(D, V): returns the result of shifting
independent <em>blocks</em> right by <code class="docutils literal notranslate"><span class="pre">int</span></code> lanes, shifting in zeros even
for partial vectors. <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>CombineShiftRightBytes</strong>&lt;int&gt;(D, V hi, V lo): returns a
vector of <em>blocks</em> each the result of shifting two concatenated
<em>blocks</em> <code class="docutils literal notranslate"><span class="pre">hi[i]</span> <span class="pre">||</span> <span class="pre">lo[i]</span></code> right by <code class="docutils literal notranslate"><span class="pre">int</span></code> bytes [1, 16). <code class="docutils literal notranslate"><span class="pre">D</span></code>
is <code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</div>
</div>
</li>
<li><p>V <strong>CombineShiftRightLanes</strong>&lt;int&gt;(D, V hi, V lo): returns a vector
of <em>blocks</em> each the result of shifting two concatenated <em>blocks</em>
<code class="docutils literal notranslate"><span class="pre">hi[i]</span> <span class="pre">||</span> <span class="pre">lo[i]</span></code> right by <code class="docutils literal notranslate"><span class="pre">int</span></code> lanes [1, 16/sizeof(T)). <code class="docutils literal notranslate"><span class="pre">D</span></code> is
<code class="docutils literal notranslate"><span class="pre">DFromV&lt;V&gt;</span></code>.</p></li>
</ul>
</div>
<div class="section" id="other-fixed-pattern-permutations-within-blocks">
<h4>Other fixed-pattern permutations within blocks<a class="headerlink" href="#other-fixed-pattern-permutations-within-blocks" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>V <strong>OddEven</strong>(V a, V b): returns a vector whose odd lanes are taken
from <code class="docutils literal notranslate"><span class="pre">a</span></code> and the even lanes from <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p>V <strong>DupEven</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">r</span></code>, the result of copying even lanes
to the next higher-indexed lane. For each even lane index <code class="docutils literal notranslate"><span class="pre">i</span></code>,
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">==</span> <span class="pre">v[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">r[i</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">==</span> <span class="pre">v[i]</span></code>.</p></li>
<li><p>V <strong>DupOdd</strong>(V v): returns <code class="docutils literal notranslate"><span class="pre">r</span></code>, the result of copying odd lanes
to the previous lower-indexed lane. For each odd lane index <code class="docutils literal notranslate"><span class="pre">i</span></code>,
<code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">==</span>&#160;&#160;&#160;&#160; <span class="pre">v[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">r[i</span> <span class="pre">-</span> <span class="pre">1]</span> <span class="pre">==</span> <span class="pre">v[i]</span></code>. Only available if
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>.</p></li>
</ul>
<p>Ops in this section are only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32}</span></code></div>
<div class="line">V <strong>Shuffle1032</strong>(V): returns <em>blocks</em> with 64-bit halves
swapped.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32}</span></code></div>
<div class="line">V <strong>Shuffle0321</strong>(V): returns <em>blocks</em> rotated right (toward the
lower end) by 32 bits.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32}</span></code></div>
<div class="line">V <strong>Shuffle2103</strong>(V): returns <em>blocks</em> rotated left (toward the
upper end) by 32 bits.</div>
</div>
</li>
</ul>
<p>The following are equivalent to <code class="docutils literal notranslate"><span class="pre">Reverse2</span></code> or <code class="docutils literal notranslate"><span class="pre">Reverse4</span></code>, which
should be used instead because they are more general:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32}</span></code></div>
<div class="line">V <strong>Shuffle2301</strong>(V): returns <em>blocks</em> with 32-bit halves swapped
inside 64-bit halves.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{64}</span></code></div>
<div class="line">V <strong>Shuffle01</strong>(V): returns <em>blocks</em> with 64-bit halves swapped.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i,f}{32}</span></code></div>
<div class="line">V <strong>Shuffle0123</strong>(V): returns <em>blocks</em> with lanes in reverse
order.</div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="swizzle">
<h3>Swizzle<a class="headerlink" href="#swizzle" title="Permalink to this heading"></a></h3>
<div class="section" id="reverse">
<h4>Reverse<a class="headerlink" href="#reverse" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>V <strong>Reverse</strong>(D, V a) returns a vector with lanes in reversed order
(<code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">==</span> <span class="pre">a[Lanes(D())</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">i]</span></code>).</p></li>
<li><p>V <strong>ReverseBlocks</strong>(V v): returns a vector with blocks in reversed
order.</p></li>
</ul>
<p>The following <code class="docutils literal notranslate"><span class="pre">ReverseN</span></code> must not be called if <code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">&lt;</span> <span class="pre">N</span></code>:</p>
<ul>
<li><p>V <strong>Reverse2</strong>(D, V a) returns a vector with each group of 2
contiguous lanes in reversed order (<code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">^</span> <span class="pre">1]</span></code>).</p></li>
<li><p>V <strong>Reverse4</strong>(D, V a) returns a vector with each group of 4
contiguous lanes in reversed order (<code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">^</span> <span class="pre">3]</span></code>).</p></li>
<li><p>V <strong>Reverse8</strong>(D, V a) returns a vector with each group of 8
contiguous lanes in reversed order (<code class="docutils literal notranslate"><span class="pre">out[i]</span> <span class="pre">==</span> <span class="pre">a[i</span> <span class="pre">^</span> <span class="pre">7]</span></code>).</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}{16,32,64}</span></code></div>
<div class="line">V <strong>ReverseLaneBytes</strong>(V a) returns a vector where the bytes of
each lane are swapped.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">{u,i}</span></code></div>
<div class="line">V <strong>ReverseBits</strong>(V a) returns a vector where the bits of each
lane are reversed.</div>
</div>
</li>
</ul>
</div>
<div class="section" id="user-specified-permutation-across-blocks">
<h4>User-specified permutation across blocks<a class="headerlink" href="#user-specified-permutation-across-blocks" title="Permalink to this heading"></a></h4>
<ul>
<li><p>V <strong>TableLookupLanes</strong>(V a, unspecified) returns a vector of
<code class="docutils literal notranslate"><span class="pre">a[indices[i]]</span></code>, where <code class="docutils literal notranslate"><span class="pre">unspecified</span></code> is the return value of
<code class="docutils literal notranslate"><span class="pre">SetTableIndices(D,</span> <span class="pre">&amp;indices[0])</span></code> or <code class="docutils literal notranslate"><span class="pre">IndicesFromVec</span></code>. The
indices are not limited to blocks, hence this is slower than
<code class="docutils literal notranslate"><span class="pre">TableLookupBytes*</span></code> on AVX2/AVX-512. Results are
implementation-defined unless <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">indices[i]</span> <span class="pre">&lt;</span>&#160;&#160;&#160;&#160; <span class="pre">Lanes(D())</span></code>
and <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;=</span> <span class="pre">LimitsMax&lt;TFromD&lt;RebindToUnsigned&lt;D&gt;&gt;&gt;()</span></code>. Note
that the latter condition is only a (potential) limitation for 8-bit
lanes on the RVV target; otherwise,
<code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">&lt;=</span> <span class="pre">LimitsMax&lt;..&gt;()</span></code>. <code class="docutils literal notranslate"><span class="pre">indices</span></code> are always integers,
even if <code class="docutils literal notranslate"><span class="pre">V</span></code> is a floating-point type.</p></li>
<li><p>V <strong>TwoTablesLookupLanes</strong>(D d, V a, V b, unspecified) returns a
vector of <code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">N</span> <span class="pre">?</span> <span class="pre">a[indices[i]]</span> <span class="pre">:</span> <span class="pre">b[indices[i]</span> <span class="pre">-</span> <span class="pre">N]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">unspecified</span></code> is the return value of
<code class="docutils literal notranslate"><span class="pre">SetTableIndices(d,</span> <span class="pre">&amp;indices[0])</span></code> or <code class="docutils literal notranslate"><span class="pre">IndicesFromVec</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span></code>
is equal to <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>. The indices are not limited to blocks.
Results are implementation-defined unless
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">2</span> <span class="pre">*</span>&#160;&#160;&#160;&#160; <span class="pre">Lanes(d)</span></code> and
<code class="docutils literal notranslate"><span class="pre">indices[i]</span> <span class="pre">&lt;=</span> <span class="pre">LimitsMax&lt;TFromD&lt;RebindToUnsigned&lt;D&gt;&gt;&gt;()</span></code>. Note that
the latter condition is only a (potential) limitation for 8-bit lanes
on the RVV target; otherwise, <code class="docutils literal notranslate"><span class="pre">Lanes(D())</span> <span class="pre">&lt;=</span> <span class="pre">LimitsMax&lt;..&gt;()</span></code>.
<code class="docutils literal notranslate"><span class="pre">indices</span></code> are always integers, even if <code class="docutils literal notranslate"><span class="pre">V</span></code> is a floating-point
type.</p></li>
<li><p>V <strong>TwoTablesLookupLanes</strong>(V a, V b, unspecified) returns
<code class="docutils literal notranslate"><span class="pre">TwoTablesLookupLanes(DFromV&lt;V&gt;(),</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">indices)</span></code>, see above. Note
that the results of <code class="docutils literal notranslate"><span class="pre">TwoTablesLookupLanes(d,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">indices)</span></code> may
differ from <code class="docutils literal notranslate"><span class="pre">TwoTablesLookupLanes(a,</span> <span class="pre">b,</span> <span class="pre">indices)</span></code> on RVV/SVE if
<code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">&lt;</span>&#160;&#160;&#160;&#160; <span class="pre">Lanes(DFromV&lt;V&gt;())</span></code>.</p></li>
<li><p>unspecified <strong>IndicesFromVec</strong>(D d, V idx) prepares for
<code class="docutils literal notranslate"><span class="pre">TableLookupLanes</span></code> with integer indices in <code class="docutils literal notranslate"><span class="pre">idx</span></code>, which must be
the same bit width as <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code> and in the range
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(d))</span></code>, but need not be unique.</p></li>
<li><p>unspecified <strong>SetTableIndices</strong>(D d, TI* idx) prepares for
<code class="docutils literal notranslate"><span class="pre">TableLookupLanes</span></code> by loading <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> integer indices from
<code class="docutils literal notranslate"><span class="pre">idx</span></code>, which must be in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">Lanes(d))</span></code> but need
not be unique. The index type <code class="docutils literal notranslate"><span class="pre">TI</span></code> must be an integer of the same
size as <code class="docutils literal notranslate"><span class="pre">TFromD&lt;D&gt;</span></code>.</p></li>
<li><p>V <strong>Per4LaneBlockShuffle</strong>&lt;size_t kIdx3, size_t kIdx2, size_t
kIdx1, size_t kIdx0&gt;(V v) does a per 4-lane block shuffle of <code class="docutils literal notranslate"><span class="pre">v</span></code> if
<code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code> is greater than or equal to 4 or a shuffle of
the full vector if <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code> is less than 4.</p>
<p><code class="docutils literal notranslate"><span class="pre">kIdx0</span></code>, <code class="docutils literal notranslate"><span class="pre">kIdx1</span></code>, <code class="docutils literal notranslate"><span class="pre">kIdx2</span></code>, and <code class="docutils literal notranslate"><span class="pre">kIdx3</span></code> must all be between 0
and 3.</p>
<p>Per4LaneBlockShuffle is equivalent to doing a TableLookupLanes with
the following indices (but Per4LaneBlockShuffle is more efficient
than TableLookupLanes on some platforms):
<code class="docutils literal notranslate"><span class="pre">{kIdx0,</span> <span class="pre">kIdx1,</span> <span class="pre">kIdx2,</span> <span class="pre">kIdx3,</span> <span class="pre">kIdx0+4,</span> <span class="pre">kIdx1+4,</span> <span class="pre">kIdx2+4,</span> <span class="pre">kIdx3+4,</span> <span class="pre">...}</span></code></p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code> is less than 4 and
<code class="docutils literal notranslate"><span class="pre">kIdx0</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(DFromV&lt;V&gt;())</span></code> is true, Per4LaneBlockShuffle returns
an unspecified value in the first lane of the result. Otherwise,
Per4LaneBlockShuffle returns <code class="docutils literal notranslate"><span class="pre">v[kIdx0]</span></code> in the first lane of the
result.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span></code> is equal to 2 and <code class="docutils literal notranslate"><span class="pre">kIdx1</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> is true,
Per4LaneBlockShuffle returns an unspecified value in the second lane
of the result. Otherwise, Per4LaneBlockShuffle returns <code class="docutils literal notranslate"><span class="pre">v[kIdx1]</span></code>
in the first lane of the result.</p>
</li>
</ul>
</div>
<div class="section" id="slide-across-blocks">
<h4>Slide across blocks<a class="headerlink" href="#slide-across-blocks" title="Permalink to this heading"></a></h4>
<ul>
<li><p>V <strong>SlideUpLanes</strong>(D d, V v, size_t N): slides up <code class="docutils literal notranslate"><span class="pre">v</span></code> by <code class="docutils literal notranslate"><span class="pre">N</span></code>
lanes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;</span> <span class="pre">Lanes(d)</span></code> is true, returns a vector with the first
(lowest-index) <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">-</span> <span class="pre">N</span></code> lanes of <code class="docutils literal notranslate"><span class="pre">v</span></code> shifted up to the
upper (highest-index) <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">-</span> <span class="pre">N</span></code> lanes of the result vector and
the first (lowest-index) <code class="docutils literal notranslate"><span class="pre">N</span></code> lanes of the result vector zeroed out.</p>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">result[0..N-1]</span></code> would be zero,
<code class="docutils literal notranslate"><span class="pre">result[N]</span> <span class="pre">=</span> <span class="pre">v[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">result[N+1]</span> <span class="pre">=</span> <span class="pre">v[1]</span></code>, and so on until
<code class="docutils literal notranslate"><span class="pre">result[Lanes(d)-1]</span> <span class="pre">=</span> <span class="pre">v[Lanes(d)-1-N]</span></code>.</p>
<p>The result of SlideUpLanes is implementation-defined if
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(d)</span></code>.</p>
</li>
<li><p>V <strong>SlideDownLanes</strong>(D d, V v, size_t N): slides down <code class="docutils literal notranslate"><span class="pre">v</span></code> by
<code class="docutils literal notranslate"><span class="pre">N</span></code> lanes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;</span> <span class="pre">Lanes(d)</span></code> is true, returns a vector with the last
(highest-index) <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">-</span> <span class="pre">N</span></code> of <code class="docutils literal notranslate"><span class="pre">v</span></code> shifted down to the first
(lowest-index) <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">-</span> <span class="pre">N</span></code> lanes of the result vector and the
last (highest-index) <code class="docutils literal notranslate"><span class="pre">N</span></code> lanes of the result vector zeroed out.</p>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">result[0]</span> <span class="pre">=</span> <span class="pre">v[N]</span></code>, <code class="docutils literal notranslate"><span class="pre">result[1]</span> <span class="pre">=</span> <span class="pre">v[N</span> <span class="pre">+</span> <span class="pre">1]</span></code>, and
so on until <code class="docutils literal notranslate"><span class="pre">result[Lanes(d)-1-N]</span> <span class="pre">=</span> <span class="pre">v[Lanes(d)-1]</span></code>, and then
<code class="docutils literal notranslate"><span class="pre">result[Lanes(d)-N..N-1]</span></code> would be zero.</p>
<p>The results of SlideDownLanes is implementation-defined if
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;=</span> <span class="pre">Lanes(d)</span></code>.</p>
</li>
<li><p>V <strong>Slide1Up</strong>(D d, V v): slides up <code class="docutils literal notranslate"><span class="pre">v</span></code> by 1 lane</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">==</span> <span class="pre">1</span></code> is true, returns <code class="docutils literal notranslate"><span class="pre">Zero(d)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> is true, <code class="docutils literal notranslate"><span class="pre">Slide1Up(d,</span> <span class="pre">v)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">SlideUpLanes(d,</span> <span class="pre">v,</span> <span class="pre">1)</span></code>, but <code class="docutils literal notranslate"><span class="pre">Slide1Up(d,</span> <span class="pre">v)</span></code> is more efficient
than <code class="docutils literal notranslate"><span class="pre">SlideUpLanes(d,</span> <span class="pre">v,</span> <span class="pre">1)</span></code> on some platforms.</p>
</li>
<li><p>V <strong>Slide1Down</strong>(D d, V v): slides down <code class="docutils literal notranslate"><span class="pre">v</span></code> by 1 lane</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">==</span> <span class="pre">1</span></code> is true, returns <code class="docutils literal notranslate"><span class="pre">Zero(d)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> is true, <code class="docutils literal notranslate"><span class="pre">Slide1Down(d,</span> <span class="pre">v)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">SlideDownLanes(d,</span> <span class="pre">v,</span> <span class="pre">1)</span></code>, but <code class="docutils literal notranslate"><span class="pre">Slide1Down(d,</span> <span class="pre">v)</span></code> is more
efficient than <code class="docutils literal notranslate"><span class="pre">SlideDownLanes(d,</span> <span class="pre">v,</span> <span class="pre">1)</span></code> on some platforms.</p>
</li>
<li><p>V <strong>SlideUpBlocks</strong>&lt;int kBlocks&gt;(D d, V v) slides up <code class="docutils literal notranslate"><span class="pre">v</span></code> by
<code class="docutils literal notranslate"><span class="pre">kBlocks</span></code> blocks.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBlocks</span></code> must be between 0 and <code class="docutils literal notranslate"><span class="pre">d.MaxBlocks()</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>Equivalent to
<code class="docutils literal notranslate"><span class="pre">SlideUpLanes(d,</span> <span class="pre">v,</span> <span class="pre">kBlocks</span> <span class="pre">*</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromD&lt;D&gt;)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideUpBlocks&lt;kBlocks&gt;(d,</span> <span class="pre">v)</span></code> is more efficient than
<code class="docutils literal notranslate"><span class="pre">SlideUpLanes(d,</span> <span class="pre">v,</span> <span class="pre">kBlocks</span> <span class="pre">*</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromD&lt;D&gt;)))</span></code> on some
platforms.</p>
<p>The results of <code class="docutils literal notranslate"><span class="pre">SlideUpBlocks&lt;kBlocks&gt;(d,</span> <span class="pre">v)</span></code> is
implementation-defined if <code class="docutils literal notranslate"><span class="pre">kBlocks</span> <span class="pre">&gt;=</span> <span class="pre">Blocks(d)</span></code> is true.</p>
</li>
<li><p>V <strong>SlideDownBlocks</strong>&lt;int kBlocks&gt;(D d, V v) slides down <code class="docutils literal notranslate"><span class="pre">v</span></code> by
<code class="docutils literal notranslate"><span class="pre">kBlocks</span></code> blocks.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBlocks</span></code> must be between 0 and <code class="docutils literal notranslate"><span class="pre">d.MaxBlocks()</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>Equivalent to
<code class="docutils literal notranslate"><span class="pre">SlideDownLanes(d,</span> <span class="pre">v,</span> <span class="pre">kBlocks</span> <span class="pre">*</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromD&lt;D&gt;)))</span></code>, but
<code class="docutils literal notranslate"><span class="pre">SlideDownBlocks&lt;kBlocks&gt;(d,</span> <span class="pre">v)</span></code> is more efficient than
<code class="docutils literal notranslate"><span class="pre">SlideDownLanes(d,</span> <span class="pre">v,</span> <span class="pre">kBlocks</span> <span class="pre">*</span> <span class="pre">(16</span> <span class="pre">/</span> <span class="pre">sizeof(TFromD&lt;D&gt;)))</span></code> on some
platforms.</p>
<p>The results of <code class="docutils literal notranslate"><span class="pre">SlideDownBlocks&lt;kBlocks&gt;(d,</span> <span class="pre">v)</span></code> is
implementation-defined if <code class="docutils literal notranslate"><span class="pre">kBlocks</span> <span class="pre">&gt;=</span> <span class="pre">Blocks(d)</span></code> is true.</p>
</li>
</ul>
</div>
<div class="section" id="other-fixed-pattern-across-blocks">
<h4>Other fixed-pattern across blocks<a class="headerlink" href="#other-fixed-pattern-across-blocks" title="Permalink to this heading"></a></h4>
<ul>
<li><p>V <strong>BroadcastLane</strong>&lt;int kLane&gt;(V v): returns a vector with all of
the lanes set to <code class="docutils literal notranslate"><span class="pre">v[kLane]</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kLane</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">MaxLanes(DFromV&lt;V&gt;()))</span></code>.</p>
</li>
<li><p>V <strong>BroadcastBlock</strong>&lt;int kBlock&gt;(V v): broadcasts the 16-byte block
of vector <code class="docutils literal notranslate"><span class="pre">v</span></code> at index <code class="docutils literal notranslate"><span class="pre">kBlock</span></code> to all of the blocks of the
result vector if <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromV&lt;V&gt;)</span> <span class="pre">&gt;</span> <span class="pre">16</span></code> is
true. Otherwise, if <code class="docutils literal notranslate"><span class="pre">Lanes(DFromV&lt;V&gt;())</span> <span class="pre">*</span> <span class="pre">sizeof(TFromV&lt;V&gt;)</span> <span class="pre">&lt;=</span> <span class="pre">16</span></code>
is true, returns <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kBlock</span></code> must be in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">DFromV&lt;V&gt;().MaxBlocks())</span></code>.</p>
</li>
<li><p>V <strong>OddEvenBlocks</strong>(V a, V b): returns a vector whose odd blocks
are taken from <code class="docutils literal notranslate"><span class="pre">a</span></code> and the even blocks from <code class="docutils literal notranslate"><span class="pre">b</span></code>. Returns <code class="docutils literal notranslate"><span class="pre">b</span></code> if
the vector has no more than one block (i.e. is 128 bits or scalar).</p></li>
</ul>
<p>The following ops are undefined for vectors with less than two blocks;
callers must first check <code class="docutils literal notranslate"><span class="pre">Lanes</span></code> before calling these ops:</p>
<ul class="simple">
<li><p>V <strong>SwapAdjacentBlocks</strong>(V v): returns a vector where blocks of
index <code class="docutils literal notranslate"><span class="pre">2*i</span></code> and <code class="docutils literal notranslate"><span class="pre">2*i+1</span></code> are swapped.</p></li>
<li><p>V <strong>InterleaveEvenBlocks</strong>(D, V a, V b): returns blocks,
first/lowest the first from A, then the first from B, then the third
from A, then the third from B, etc.</p></li>
<li><p>V <strong>InterleaveOddBlocks</strong>(D, V a, V b): returns blocks,
first/lowest the second from A, then the second from B, then the
fourth from A, the fourth from B, etc.</p></li>
<li><p>V <strong>InterleaveLowerBlocks</strong>(D, V a, V b): returns blocks,
first/lowest the first from A, then the first from B, then the next
from A, then the next from B, etc.</p></li>
<li><p>V <strong>InterleaveUpperBlocks</strong>(D, V a, V b): returns blocks,
first/lowest the first in the upper half of A, then the first in the
upper half of B, then the next highest from A, then the next highest
from B, etc.</p></li>
</ul>
</div>
</div>
<div class="section" id="reductions">
<h3>Reductions<a class="headerlink" href="#reductions" title="Permalink to this heading"></a></h3>
<p><strong>Note</strong>: Horizontal operations (across lanes of the same vector) such
as reductions are slower than normal SIMD operations and are typically
used outside critical loops.</p>
<p>The following broadcast the result to all lanes. To obtain a scalar, you
can call <code class="docutils literal notranslate"><span class="pre">GetLane</span></code> on the result, or instead use <code class="docutils literal notranslate"><span class="pre">Reduce*</span></code> below.</p>
<ul class="simple">
<li><p>V <strong>SumOfLanes</strong>(D, V v): returns the sum of all lanes in each
lane.</p></li>
<li><p>V <strong>MinOfLanes</strong>(D, V v): returns the minimum-valued lane in each
lane.</p></li>
<li><p>V <strong>MaxOfLanes</strong>(D, V v): returns the maximum-valued lane in each
lane.</p></li>
</ul>
<p>The following are equivalent to <code class="docutils literal notranslate"><span class="pre">GetLane(SumOfLanes(d,</span> <span class="pre">v))</span></code> etc. but
potentially more efficient on some targets.</p>
<ul class="simple">
<li><p>T <strong>ReduceSum</strong>(D, V v): returns the sum of all lanes.</p></li>
<li><p>T <strong>ReduceMin</strong>(D, V v): returns the minimum of all lanes.</p></li>
<li><p>T <strong>ReduceMax</strong>(D, V v): returns the maximum of all lanes.</p></li>
</ul>
</div>
<div class="section" id="masked-reductions">
<h3>Masked reductions<a class="headerlink" href="#masked-reductions" title="Permalink to this heading"></a></h3>
<p><strong>Note</strong>: Horizontal operations (across lanes of the same vector) such
as reductions are slower than normal SIMD operations and are typically
used outside critical loops.</p>
<p>All ops in this section ignore lanes where <code class="docutils literal notranslate"><span class="pre">mask=false</span></code>. These are
equivalent to, and potentially more efficient than,
<code class="docutils literal notranslate"><span class="pre">GetLane(SumOfLanes(d,</span> <span class="pre">IfThenElseZero(m,</span> <span class="pre">v)))</span></code> etc. The result is
implementation-defined when all mask elements are false.</p>
<ul class="simple">
<li><p>T <strong>MaskedReduceSum</strong>(D, M m, V v): returns the sum of all lanes
where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p>T <strong>MaskedReduceMin</strong>(D, M m, V v): returns the minimum of all
lanes where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p>T <strong>MaskedReduceMax</strong>(D, M m, V v): returns the maximum of all
lanes where <code class="docutils literal notranslate"><span class="pre">m[i]</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
</ul>
</div>
<div class="section" id="crypto">
<h3>Crypto<a class="headerlink" href="#crypto" title="Permalink to this heading"></a></h3>
<p>Ops in this section are only available if <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span></code>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESRound</strong>(V state, V round_key): one round of AES
encryption: <code class="docutils literal notranslate"><span class="pre">MixColumns(SubBytes(ShiftRows(state)))</span> <span class="pre">^</span> <span class="pre">round_key</span></code>.
This matches x86 AES-NI. The latency is independent of the input
values.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESLastRound</strong>(V state, V round_key): the last round of AES
encryption: <code class="docutils literal notranslate"><span class="pre">SubBytes(ShiftRows(state))</span> <span class="pre">^</span> <span class="pre">round_key</span></code>. This
matches x86 AES-NI. The latency is independent of the input values.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESRoundInv</strong>(V state, V round_key): one round of AES
decryption using the AES Equivalent Inverse Cipher:
<code class="docutils literal notranslate"><span class="pre">InvMixColumns(InvShiftRows(InvSubBytes(state)))</span> <span class="pre">^</span> <span class="pre">round_key</span></code>.
This matches x86 AES-NI. The latency is independent of the input
values.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESLastRoundInv</strong>(V state, V round_key): the last round of
AES decryption: <code class="docutils literal notranslate"><span class="pre">InvShiftRows(InvSubBytes(state))</span> <span class="pre">^</span> <span class="pre">round_key</span></code>.
This matches x86 AES-NI. The latency is independent of the input
values.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESInvMixColumns</strong>(V state): the InvMixColumns operation of
the AES decryption algorithm. AESInvMixColumns is used in the key
expansion step of the AES Equivalent Inverse Cipher algorithm. The
latency is independent of the input values.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u8</span></code></div>
<div class="line">V <strong>AESKeyGenAssist</strong>&lt;uint8_t kRcon&gt;(V v): AES key generation
assist operation</div>
</div>
<p>The AESKeyGenAssist operation is equivalent to doing the following,
which matches the behavior of the x86 AES-NI AESKEYGENASSIST
instruction:</p>
<ul class="simple">
<li><p>Applying the AES SubBytes operation to each byte of <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p></li>
<li><p>Doing a TableLookupBytes operation on each 128-bit block of the
result of the <code class="docutils literal notranslate"><span class="pre">SubBytes(v)</span></code> operation with the following indices
(which is broadcast to each 128-bit block in the case of vectors
with 32 or more lanes):
<code class="docutils literal notranslate"><span class="pre">{4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">4,</span> <span class="pre">12,</span> <span class="pre">13,</span> <span class="pre">14,</span> <span class="pre">15,</span> <span class="pre">13,</span> <span class="pre">14,</span> <span class="pre">15,</span> <span class="pre">12}</span></code></p></li>
<li><p>Doing a bitwise XOR operation with the following vector (where
<code class="docutils literal notranslate"><span class="pre">kRcon</span></code> is the rounding constant that is the first template
argument of the AESKeyGenAssist function and where the below
vector is broadcasted to each 128-bit block in the case of vectors
with 32 or more lanes):
<code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">kRcon,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">kRcon,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0}</span></code></p></li>
</ul>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>CLMulLower</strong>(V a, V b): carryless multiplication of the lower
64 bits of each 128-bit block into a 128-bit product. The latency
is independent of the input values (assuming that is true of normal
integer multiplication) so this can safely be used in crypto.
Applications that wish to multiply upper with lower halves can
<code class="docutils literal notranslate"><span class="pre">Shuffle01</span></code> one of the operands; on x86 that is expected to be
latency-neutral.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">V</span></code>: <code class="docutils literal notranslate"><span class="pre">u64</span></code></div>
<div class="line">V <strong>CLMulUpper</strong>(V a, V b): as CLMulLower, but multiplies the
upper 64 bits of each 128-bit block.</div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="preprocessor-macros">
<h2>Preprocessor macros<a class="headerlink" href="#preprocessor-macros" title="Permalink to this heading"></a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_ALIGN</span></code>: Prefix for stack-allocated (i.e. automatic storage
duration) arrays to ensure they have suitable alignment for
Load()/Store(). This is specific to <code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span></code> and should only be
used inside <code class="docutils literal notranslate"><span class="pre">HWY_NAMESPACE</span></code>.</p>
<p>Arrays should also only be used for partial (&lt;= 128-bit) vectors, or
<code class="docutils literal notranslate"><span class="pre">LoadDup128</span></code>, because full vectors may be too large for the stack
and should be heap-allocated instead (see aligned_allocator.h).</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">HWY_ALIGN</span> <span class="pre">float</span> <span class="pre">lanes[4];</span></code></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_ALIGN_MAX</span></code>: as <code class="docutils literal notranslate"><span class="pre">HWY_ALIGN</span></code>, but independent of
<code class="docutils literal notranslate"><span class="pre">HWY_TARGET</span></code> and may be used outside <code class="docutils literal notranslate"><span class="pre">HWY_NAMESPACE</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_RESTRICT</span></code>: use after a pointer, e.g. <code class="docutils literal notranslate"><span class="pre">T*</span> <span class="pre">HWY_RESTRICT</span> <span class="pre">p</span></code>, to
indicate the pointer is not aliased, i.e. it is the only way to
access the data. This may improve code generation by preventing
unnecessary reloads.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_LIKELY</span></code>: use <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(HWY_LIKELY(condition))</span></code> to signal to the
compiler that <code class="docutils literal notranslate"><span class="pre">condition</span></code> is likely to be true. This may improve
performance by influencing the layout of the generated code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_UNLIKELY</span></code>: like <code class="docutils literal notranslate"><span class="pre">HWY_LIKELY</span></code>, but for conditions likely to
be false.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_UNREACHABLE;</span></code>: signals to the compiler that control will never
reach this point, which may improve code generation.</p></li>
</ul>
</div>
<div class="section" id="advanced-macros">
<h2>Advanced macros<a class="headerlink" href="#advanced-macros" title="Permalink to this heading"></a></h2>
<p>Beware that these macros describe the current target being compiled.
Imagine a test (e.g. sort_test) with SIMD code that also uses dynamic
dispatch. There we must test the macros of the target <em>we will call</em>,
e.g. via <code class="docutils literal notranslate"><span class="pre">hwy::HaveFloat64()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">HWY_HAVE_FLOAT64</span></code>, which
describes the current target.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_IDE</span></code> is 0 except when parsed by IDEs; adding it to conditions
such as <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">HWY_TARGET</span> <span class="pre">!=</span> <span class="pre">HWY_SCALAR</span> <span class="pre">||</span> <span class="pre">HWY_IDE</span></code> avoids code
appearing greyed out.
Note for clangd users: <a class="reference external" href="https://github.com/clangd/clangd/issues/581">there are no predefined macros in
clangd</a>, so you must
manually add <code class="docutils literal notranslate"><span class="pre">__CLANGD__</span></code> macro so we can detect the presence of
clangd. This can be easily done by adding these two lines to your
project’s <code class="docutils literal notranslate"><span class="pre">.clangd</span></code> file: <code class="docutils literal notranslate"><span class="pre">CompileFlags:</span> <span class="pre">Add:</span> <span class="pre">[-D__CLANGD__]</span></code></p></li>
</ul>
<p>The following indicate full support for certain lane types and expand to
1 or 0.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_INTEGER64</span></code>: support for 64-bit signed/unsigned integer
lanes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_FLOAT16</span></code>: support for 16-bit floating-point lanes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_FLOAT64</span></code>: support for double-precision floating-point
lanes.</p></li>
</ul>
<p>The above were previously known as <code class="docutils literal notranslate"><span class="pre">HWY_CAP_INTEGER64</span></code>,
<code class="docutils literal notranslate"><span class="pre">HWY_CAP_FLOAT16</span></code>, and <code class="docutils literal notranslate"><span class="pre">HWY_CAP_FLOAT64</span></code>, respectively. Those
<code class="docutils literal notranslate"><span class="pre">HWY_CAP_*</span></code> names are DEPRECATED.</p>
<p>Even if <code class="docutils literal notranslate"><span class="pre">HWY_HAVE_FLOAT16</span></code> is 0, the following ops generally support
<code class="docutils literal notranslate"><span class="pre">float16_t</span></code> and <code class="docutils literal notranslate"><span class="pre">bfloat16_t</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Lanes</span></code>, <code class="docutils literal notranslate"><span class="pre">MaxLanes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Zero</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code>, <code class="docutils literal notranslate"><span class="pre">Undefined</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BitCast</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Load</span></code>, <code class="docutils literal notranslate"><span class="pre">LoadU</span></code>, <code class="docutils literal notranslate"><span class="pre">LoadN</span></code>, <code class="docutils literal notranslate"><span class="pre">LoadNOr</span></code>,
<code class="docutils literal notranslate"><span class="pre">LoadInterleaved[234]</span></code>, <code class="docutils literal notranslate"><span class="pre">MaskedLoad</span></code>, <code class="docutils literal notranslate"><span class="pre">MaskedLoadOr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Store</span></code>, <code class="docutils literal notranslate"><span class="pre">StoreU</span></code>, <code class="docutils literal notranslate"><span class="pre">StoreN</span></code>, <code class="docutils literal notranslate"><span class="pre">StoreInterleaved[234]</span></code>,
<code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PromoteTo</span></code>, <code class="docutils literal notranslate"><span class="pre">DemoteTo</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PromoteUpperTo</span></code>, <code class="docutils literal notranslate"><span class="pre">PromoteLowerTo</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PromoteEvenTo</span></code>, <code class="docutils literal notranslate"><span class="pre">PromoteOddTo</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Combine</span></code>, <code class="docutils literal notranslate"><span class="pre">InsertLane</span></code>, <code class="docutils literal notranslate"><span class="pre">ZeroExtendVector</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RebindMask</span></code>, <code class="docutils literal notranslate"><span class="pre">FirstN</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IfThenElse</span></code>, <code class="docutils literal notranslate"><span class="pre">IfThenElseZero</span></code>, <code class="docutils literal notranslate"><span class="pre">IfThenZeroElse</span></code></p></li>
</ul>
<p>Exception: <code class="docutils literal notranslate"><span class="pre">UpperHalf</span></code>, <code class="docutils literal notranslate"><span class="pre">PromoteUpperTo</span></code>, <code class="docutils literal notranslate"><span class="pre">PromoteOddTo</span></code> and
<code class="docutils literal notranslate"><span class="pre">Combine</span></code> are not supported for the <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code> target.</p>
<p><code class="docutils literal notranslate"><span class="pre">Neg</span></code> also supports <code class="docutils literal notranslate"><span class="pre">float16_t</span></code> and <code class="docutils literal notranslate"><span class="pre">*Demote2To</span></code> also supports
<code class="docutils literal notranslate"><span class="pre">bfloat16_t</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_SCALABLE</span></code> indicates vector sizes are unknown at compile
time, and determined by the CPU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_CONSTEXPR_LANES</span></code> is 1 if <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code> is <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.
This is always 0 <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">HWY_HAVE_SCALABLE</span></code>, and may also be 0 in
other cases, currently including debug builds.
<code class="docutils literal notranslate"><span class="pre">HWY_LANES_CONSTEXPR</span></code> replaces the <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> keyword for this
usage. It expands to <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> or nothing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_HAVE_TUPLE</span></code> indicates <code class="docutils literal notranslate"><span class="pre">Vec{2-4}</span></code>, <code class="docutils literal notranslate"><span class="pre">Create{2-4}</span></code> and
<code class="docutils literal notranslate"><span class="pre">Get{2-4}</span></code> are usable. This is already true
<code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">!HWY_HAVE_SCALABLE</span></code>, and for SVE targets, and the RVV target
when using Clang 16. We anticipate it will also become, and then
remain, true starting with GCC 14.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_MEM_OPS_MIGHT_FAULT</span></code> is 1 iff <code class="docutils literal notranslate"><span class="pre">MaskedLoad</span></code> may trigger a
(page) fault when attempting to load lanes from unmapped memory, even
if the corresponding mask element is false. This is the case on
ASAN/MSAN builds, AMD x86 prior to AVX-512, and Arm NEON. If so,
users can prevent faults by ensuring memory addresses are aligned to
the vector size or at least padded (allocation size increased by at
least <code class="docutils literal notranslate"><span class="pre">Lanes(d)</span></code>). Note that <code class="docutils literal notranslate"><span class="pre">LoadN</span></code> and <code class="docutils literal notranslate"><span class="pre">StoreN</span></code> never fault,
regardless of the value of this macro.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_NATIVE_FMA</span></code> expands to 1 if the <code class="docutils literal notranslate"><span class="pre">MulAdd</span></code> etc. ops use native
fused multiply-add for floating-point inputs. Otherwise,
<code class="docutils literal notranslate"><span class="pre">MulAdd(f,</span> <span class="pre">m,</span> <span class="pre">a)</span></code> is implemented as <code class="docutils literal notranslate"><span class="pre">Add(Mul(f,</span> <span class="pre">m),</span> <span class="pre">a)</span></code>. Checking
this can be useful for increasing the tolerance of expected results
(around 1E-5 or 1E-6).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_NATIVE_MASK</span></code> expands to 1 if the <code class="docutils literal notranslate"><span class="pre">Masked*</span></code> etc. ops use
native masking. If so, the masking is zero-cost, otherwise they
typically involve an extra AND operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_NATIVE_DOT_BF16</span></code> expands to 1 if <code class="docutils literal notranslate"><span class="pre">ReorderWidenMulAccumulate</span></code>
uses a native instruction rather than masking and f32 <code class="docutils literal notranslate"><span class="pre">MulAdd</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_NATIVE_INTERLEAVE_WHOLE</span></code> expands to 1 if
<code class="docutils literal notranslate"><span class="pre">InterleaveWholeLower/Upper</span></code> are at least as efficient as
<code class="docutils literal notranslate"><span class="pre">InterleaveLower/Upper</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_IS_LITTLE_ENDIAN</span></code> expands to 1 on little-endian targets and to
0 on big-endian targets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_IS_BIG_ENDIAN</span></code> expands to 1 on big-endian targets and to 0 on
little-endian targets.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_MAX_BYTES</span></code> is an upper bound on the size of a full vector,
suitable for use in <code class="docutils literal notranslate"><span class="pre">#if</span></code> expressions. Except for the
<code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code> target, it is equal to the vector size if
<code class="docutils literal notranslate"><span class="pre">!HWY_HAVE_SCALABLE</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_MIN_BYTES</span></code> is a lower bound on the size of a full vector,
suitable for use in <code class="docutils literal notranslate"><span class="pre">#if</span></code> expressions. Except for the
<code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code> target, it is equal to the vector size if
<code class="docutils literal notranslate"><span class="pre">!HWY_HAVE_SCALABLE</span></code>.</p></li>
</ul>
<p>The following are DEPRECATED in favor of <code class="docutils literal notranslate"><span class="pre">HWY_MIN_BYTES</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_CAP_GE256</span></code>: the current target supports vectors of &gt;= 256
bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_CAP_GE512</span></code>: the current target supports vectors of &gt;= 512
bits.</p></li>
</ul>
</div>
<div class="section" id="detecting-supported-targets">
<h2>Detecting supported targets<a class="headerlink" href="#detecting-supported-targets" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">SupportedTargets()</span></code> returns a non-cached (re-initialized on each
call) bitfield of the targets supported on the current CPU, detected
using CPUID on x86 or equivalent. This may include targets that are not
in <code class="docutils literal notranslate"><span class="pre">HWY_TARGETS</span></code>. Conversely, <code class="docutils literal notranslate"><span class="pre">HWY_TARGETS</span></code> may include unsupported
targets. If there is no overlap, the binary will likely crash. This can
only happen if:</p>
<ul class="simple">
<li><p>the specified baseline is not supported by the current CPU, which
contradicts the definition of baseline, so the configuration is
invalid; or</p></li>
<li><p>the baseline does not include the enabled/attainable target(s), which
are also not supported by the current CPU, and baseline targets (in
particular <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code>) were explicitly disabled.</p></li>
</ul>
</div>
<div class="section" id="advanced-configuration-macros">
<h2>Advanced configuration macros<a class="headerlink" href="#advanced-configuration-macros" title="Permalink to this heading"></a></h2>
<p>The following macros govern which targets to generate. Unless specified
otherwise, they may be defined per translation unit, e.g. to disable
&gt;128 bit vectors in modules that do not benefit from them (if
bandwidth-limited or only called occasionally). This is safe because
<code class="docutils literal notranslate"><span class="pre">HWY_TARGETS</span></code> always includes at least one baseline target which
<code class="docutils literal notranslate"><span class="pre">HWY_EXPORT</span></code> can use.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_DISABLE_CACHE_CONTROL</span></code> makes the cache-control functions
no-ops.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_DISABLE_BMI2_FMA</span></code> prevents emitting BMI/BMI2/FMA instructions.
This allows using AVX2 in VMs that do not support the other
instructions, but only if defined for all translation units.</p></li>
</ul>
<p>The following <code class="docutils literal notranslate"><span class="pre">*_TARGETS</span></code> are zero or more <code class="docutils literal notranslate"><span class="pre">HWY_Target</span></code> bits and can
be defined as an expression,
e.g. <code class="docutils literal notranslate"><span class="pre">-DHWY_DISABLED_TARGETS=(HWY_SSE4|HWY_AVX3)</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_BROKEN_TARGETS</span></code> defaults to a blocklist of known compiler
bugs. Defining to 0 disables the blocklist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_DISABLED_TARGETS</span></code> defaults to zero. This allows explicitly
disabling targets without interfering with the blocklist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_BASELINE_TARGETS</span></code> defaults to the set whose predefined macros
are defined (i.e. those for which the corresponding flag,
e.g. -mavx2, was passed to the compiler). If specified, this should
be the same for all translation units, otherwise the safety check in
SupportedTargets (that all enabled baseline targets are supported)
will not report a mismatch for the targets specified in other
translation units.</p></li>
</ul>
<p>Zero or one of the following macros may be defined to replace the
default policy for selecting <code class="docutils literal notranslate"><span class="pre">HWY_TARGETS</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_EMU128</span></code> selects only <code class="docutils literal notranslate"><span class="pre">HWY_EMU128</span></code>, which avoids
intrinsics but implements all ops using standard C++.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_SCALAR</span></code> selects only <code class="docutils literal notranslate"><span class="pre">HWY_SCALAR</span></code>, which
implements single-lane-only ops using standard C++.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_STATIC</span></code> selects only <code class="docutils literal notranslate"><span class="pre">HWY_STATIC_TARGET</span></code>, which
effectively disables dynamic dispatch.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ALL_ATTAINABLE</span></code> selects all attainable targets
(i.e. enabled and permitted by the compiler, independently of
autovectorization), which maximizes coverage in tests. Defining
<code class="docutils literal notranslate"><span class="pre">HWY_IS_TEST</span></code>, which CMake does for the Highway tests, has the same
effect.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HWY_SKIP_NON_BEST_BASELINE</span></code> compiles all targets at least as good
as the baseline. This is also the default if nothing is defined. By
skipping targets older than the baseline, this reduces binary size
and may resolve compile errors caused by conflicts between dynamic
dispatch and -m flags.</p></li>
</ul>
<p>At most one <code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_*</span></code> may be defined.
<code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ALL_ATTAINABLE</span></code> may also be defined even if one of
<code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ONLY_*</span></code> is, but will then be ignored because the flags
are tested in the order listed. As an exception,
<code class="docutils literal notranslate"><span class="pre">HWY_SKIP_NON_BEST_BASELINE</span></code> overrides the effect of
<code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_ALL_ATTAINABLE</span></code> and <code class="docutils literal notranslate"><span class="pre">HWY_IS_TEST</span></code>.</p>
<p>As a workaround, you can define <code class="docutils literal notranslate"><span class="pre">HWY_DISABLE_ATTR</span></code> to prevent
<code class="docutils literal notranslate"><span class="pre">HWY_ATTR</span></code> and <code class="docutils literal notranslate"><span class="pre">HWY_BEFORE_NAMESPACE</span></code> from attaching target
attributes to functions. This is useful for older GCC on POWER targets.
For example, the <code class="docutils literal notranslate"><span class="pre">-mcpu=power10</span></code> flag conflicts with our attributes.
Unlike most other platforms, POWER has some ‘inverted’ attributes that
take away features rather than adding. <code class="docutils literal notranslate"><span class="pre">HWY_DISABLE_ATTR</span></code> prevents the
resulting inlining error; GCC 13 also appears to fix the issue. When
specifying this, you must also pass all <code class="docutils literal notranslate"><span class="pre">-m</span></code> compiler flags required
for any targets that the above <code class="docutils literal notranslate"><span class="pre">HWY_COMPILE_*</span></code> policies enable.</p>
</div>
<div class="section" id="compiler-support">
<h2>Compiler support<a class="headerlink" href="#compiler-support" title="Permalink to this heading"></a></h2>
<p>Clang and GCC require opting into SIMD intrinsics, e.g. via <code class="docutils literal notranslate"><span class="pre">-mavx2</span></code>
flags. However, the flag enables AVX2 instructions in the entire
translation unit, which may violate the one-definition rule (that all
versions of a function such as <code class="docutils literal notranslate"><span class="pre">std::abs</span></code> are equivalent, thus the
linker may choose any). This can cause crashes if non-SIMD functions are
defined outside of a target-specific namespace, and the linker happens
to choose the AVX2 version, which means it may be called without
verifying AVX2 is indeed supported.</p>
<p>To prevent this problem, we use target-specific attributes introduced
via <code class="docutils literal notranslate"><span class="pre">#pragma</span></code>. Function using SIMD must reside between
<code class="docutils literal notranslate"><span class="pre">HWY_BEFORE_NAMESPACE</span></code> and <code class="docutils literal notranslate"><span class="pre">HWY_AFTER_NAMESPACE</span></code>. Conversely,
non-SIMD functions and in particular, <code class="docutils literal notranslate"><span class="pre">#include</span></code> of normal or standard
library headers must NOT reside between <code class="docutils literal notranslate"><span class="pre">HWY_BEFORE_NAMESPACE</span></code> and
<code class="docutils literal notranslate"><span class="pre">HWY_AFTER_NAMESPACE</span></code>. Alternatively, individual functions may be
prefixed with <code class="docutils literal notranslate"><span class="pre">HWY_ATTR</span></code>, which is more verbose, but ensures that
<code class="docutils literal notranslate"><span class="pre">#include</span></code>-d functions are not covered by target-specific attributes.</p>
<p>WARNING: avoid non-local static objects (namespace scope ‘global
variables’) between <code class="docutils literal notranslate"><span class="pre">HWY_BEFORE_NAMESPACE</span></code> and
<code class="docutils literal notranslate"><span class="pre">HWY_AFTER_NAMESPACE</span></code>. We have observed crashes on PPC because the
compiler seems to have generated an initializer using PPC10 code to
splat a constant to all vector lanes, see #1739. To prevent this, you
can replace static constants with a function returning the desired
value.</p>
<p>If you know the SVE vector width and are using static dispatch, you can
specify <code class="docutils literal notranslate"><span class="pre">-march=armv9-a+sve2-aes</span> <span class="pre">-msve-vector-bits=128</span></code> and Highway
will then use <code class="docutils literal notranslate"><span class="pre">HWY_SVE2_128</span></code> as the baseline. Similarly,
<code class="docutils literal notranslate"><span class="pre">-march=armv8.2-a+sve</span> <span class="pre">-msve-vector-bits=256</span></code> enables the
<code class="docutils literal notranslate"><span class="pre">HWY_SVE_256</span></code> specialization for Neoverse V1. Note that these flags
are unnecessary when using dynamic dispatch. Highway will automatically
detect and dispatch to the best available target, including
<code class="docutils literal notranslate"><span class="pre">HWY_SVE2_128</span></code> or <code class="docutils literal notranslate"><span class="pre">HWY_SVE_256</span></code>.</p>
<p>Immediates (compile-time constants) are specified as template arguments
to avoid constant-propagation issues with Clang on Arm.</p>
</div>
<div class="section" id="type-traits">
<h2>Type traits<a class="headerlink" href="#type-traits" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IsFloat&lt;T&gt;()</span></code> returns true if the <code class="docutils literal notranslate"><span class="pre">T</span></code> is a floating-point type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IsSigned&lt;T&gt;()</span></code> returns true if the <code class="docutils literal notranslate"><span class="pre">T</span></code> is a signed or
floating-point type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LimitsMin/Max&lt;T&gt;()</span></code> return the smallest/largest value
representable in integer <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SizeTag&lt;N&gt;</span></code> is an empty struct, used to select overloaded
functions appropriate for <code class="docutils literal notranslate"><span class="pre">N</span></code> bytes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MakeUnsigned&lt;T&gt;</span></code> is an alias for an unsigned type of the same size
as <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MakeSigned&lt;T&gt;</span></code> is an alias for a signed type of the same size as
<code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MakeFloat&lt;T&gt;</span></code> is an alias for a floating-point type of the same
size as <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MakeWide&lt;T&gt;</span></code> is an alias for a type with twice the size of <code class="docutils literal notranslate"><span class="pre">T</span></code>
and the same category (unsigned/signed/float).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MakeNarrow&lt;T&gt;</span></code> is an alias for a type with half the size of <code class="docutils literal notranslate"><span class="pre">T</span></code>
and the same category (unsigned/signed/float).</p></li>
</ul>
</div>
<div class="section" id="memory-allocation">
<h2>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AllocateAligned&lt;T&gt;(items)</span></code> returns a unique pointer to newly
allocated memory for <code class="docutils literal notranslate"><span class="pre">items</span></code> elements of POD type <code class="docutils literal notranslate"><span class="pre">T</span></code>. The start
address is aligned as required by <code class="docutils literal notranslate"><span class="pre">Load/Store</span></code>. Furthermore,
successive allocations are not congruent modulo a platform-specific
alignment. This helps prevent false dependencies or cache conflicts. The
memory allocation is analogous to using <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">free()</span></code> with
a <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> since the returned items are <em>not</em> initialized or
default constructed and it is released using <code class="docutils literal notranslate"><span class="pre">FreeAlignedBytes()</span></code>
without calling <code class="docutils literal notranslate"><span class="pre">~T()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MakeUniqueAligned&lt;T&gt;(Args&amp;&amp;...</span> <span class="pre">args)</span></code> creates a single object in
newly allocated aligned memory as above but constructed passing the
<code class="docutils literal notranslate"><span class="pre">args</span></code> argument to <code class="docutils literal notranslate"><span class="pre">T</span></code>’s constructor and returning a unique
pointer to it. This is analogous to using <code class="docutils literal notranslate"><span class="pre">std::make_unique</span></code> with
<code class="docutils literal notranslate"><span class="pre">new</span></code> but for aligned memory since the object is constructed and later
destructed when the unique pointer is deleted. Typically this type <code class="docutils literal notranslate"><span class="pre">T</span></code>
is a struct containing multiple members with <code class="docutils literal notranslate"><span class="pre">HWY_ALIGN</span></code> or
<code class="docutils literal notranslate"><span class="pre">HWY_ALIGN_MAX</span></code>, or arrays whose lengths are known to be a multiple of
the vector size.</p>
<p><code class="docutils literal notranslate"><span class="pre">MakeUniqueAlignedArray&lt;T&gt;(size_t</span> <span class="pre">items,</span> <span class="pre">Args&amp;&amp;...</span> <span class="pre">args)</span></code> creates an
array of objects in newly allocated aligned memory as above and
constructs every element of the new array using the passed constructor
parameters, returning a unique pointer to the array. Note that only the
first element is guaranteed to be aligned to the vector size; because
there is no padding between elements, the alignment of the remaining
elements depends on the size of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</div>
<div class="section" id="speeding-up-code-for-older-x86-platforms">
<h2>Speeding up code for older x86 platforms<a class="headerlink" href="#speeding-up-code-for-older-x86-platforms" title="Permalink to this heading"></a></h2>
<p>Thanks to &#64;dzaima for inspiring this section.</p>
<p>It is possible to improve the performance of your code on older x86 CPUs
while remaining portable to all platforms. These older CPUs might indeed
be the ones for which optimization is most impactful, because modern
CPUs are usually faster and thus likelier to meet performance
expectations.</p>
<p>For those without AVX3, preferably avoid <code class="docutils literal notranslate"><span class="pre">Scatter*</span></code>; some algorithms
can be reformulated to use <code class="docutils literal notranslate"><span class="pre">Gather*</span></code> instead. For pre-AVX2, it is also
important to avoid <code class="docutils literal notranslate"><span class="pre">Gather*</span></code>.</p>
<p>It is typically much more efficient to pad arrays and use <code class="docutils literal notranslate"><span class="pre">Load</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">MaskedLoad</span></code> and <code class="docutils literal notranslate"><span class="pre">Store</span></code> instead of <code class="docutils literal notranslate"><span class="pre">BlendedStore</span></code>.</p>
<p>If possible, use signed 8..32 bit types instead of unsigned types for
comparisons and <code class="docutils literal notranslate"><span class="pre">Min</span></code>/<code class="docutils literal notranslate"><span class="pre">Max</span></code>.</p>
<p>Other ops which are considerably more expensive especially on SSSE3, and
preferably avoided if possible: <code class="docutils literal notranslate"><span class="pre">MulEven</span></code>, i32 <code class="docutils literal notranslate"><span class="pre">Mul</span></code>,
<code class="docutils literal notranslate"><span class="pre">Shl</span></code>/<code class="docutils literal notranslate"><span class="pre">Shr</span></code>, <code class="docutils literal notranslate"><span class="pre">Round</span></code>/<code class="docutils literal notranslate"><span class="pre">Trunc</span></code>/<code class="docutils literal notranslate"><span class="pre">Ceil</span></code>/<code class="docutils literal notranslate"><span class="pre">Floor</span></code>, float16
<code class="docutils literal notranslate"><span class="pre">PromoteTo</span></code>/<code class="docutils literal notranslate"><span class="pre">DemoteTo</span></code>, <code class="docutils literal notranslate"><span class="pre">AESRound</span></code>.</p>
<p>Ops which are moderately more expensive on older CPUs: 64-bit
<code class="docutils literal notranslate"><span class="pre">Abs</span></code>/<code class="docutils literal notranslate"><span class="pre">ShiftRight</span></code>/<code class="docutils literal notranslate"><span class="pre">ConvertTo</span></code>, i32-&gt;u16 <code class="docutils literal notranslate"><span class="pre">DemoteTo</span></code>, u32-&gt;f32
<code class="docutils literal notranslate"><span class="pre">ConvertTo</span></code>, <code class="docutils literal notranslate"><span class="pre">Not</span></code>, <code class="docutils literal notranslate"><span class="pre">IfThenElse</span></code>, <code class="docutils literal notranslate"><span class="pre">RotateRight</span></code>, <code class="docutils literal notranslate"><span class="pre">OddEven</span></code>,
<code class="docutils literal notranslate"><span class="pre">BroadcastSignBit</span></code>.</p>
<p>It is likely difficult to avoid all of these ops (about a fifth of the
total). Apps usually also cannot more efficiently achieve the same
result as any op without using it - this is an explicit design goal of
Highway. However, sometimes it is possible to restructure your code to
avoid <code class="docutils literal notranslate"><span class="pre">Not</span></code>, e.g. by hoisting it outside the SIMD code, or fusing with
<code class="docutils literal notranslate"><span class="pre">AndNot</span></code> or <code class="docutils literal notranslate"><span class="pre">CompressNot</span></code>.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="README.html" class="btn btn-neutral float-left" title="Efficient and performance-portable vector software" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="design_philosophy.html" class="btn btn-neutral float-right" title="Design philosophy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Apache 2.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      
      
     <span class="fa fa-element">
     <input class="container_toggle" type="checkbox" id="switch" name="mode">
     <label for="switch"></label>
     </span>
      
      v: test_578806572
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl>
        <dt>Languages</dt>
        
           <strong> 
          <dd><a href="/highway/en/test_578806572/">en</a></dd>
           </strong> 
        
          
          <dd><a href="/highway/zh/test_578806572/">zh</a></dd>
          
        
      </dl>
      
      
      <dl>
        <dt>Versions</dt>
        
          
          <dd><a href="/highway/en/disable_w32_warning/">disable_w32_warning</a></dd>
          
        
          
          <dd><a href="/highway/en/master/">master</a></dd>
          
        
          
          <dd><a href="/highway/en/test_407341568/">test_407341568</a></dd>
          
        
          
          <dd><a href="/highway/en/test_427688866/">test_427688866</a></dd>
          
        
          
          <dd><a href="/highway/en/test_443523054/">test_443523054</a></dd>
          
        
          
          <dd><a href="/highway/en/test_473247507/">test_473247507</a></dd>
          
        
          
          <dd><a href="/highway/en/test_516796152/">test_516796152</a></dd>
          
        
          
          <dd><a href="/highway/en/test_578459068/">test_578459068</a></dd>
          
        
           <strong> 
          <dd><a href="/highway/en/test_578806572/">test_578806572</a></dd>
           </strong> 
        
      </dl>
      
      
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="/highway/en/test_578806572/highway_en_test_578806572.epub">epub</a></dd>
        
      </dl>
      
      
      <hr/>
      Free document hosting provided by <a href="https://pages.github.com/">GitHub Pages</a>.
 
    </div>
  </div>

 <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
         .wy-nav-content { max-width: none; }
  </style>



</body>
</html>